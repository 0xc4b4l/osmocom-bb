   1              		.file	"l23_api.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.audio_set_enabled,"ax",%progbits
  12              		.align	2
  14              	audio_set_enabled:
  15              	.LFB61:
  16              		.file 1 "layer1/l23_api.c"
   1:layer1/l23_api.c **** /* Synchronous part of GSM Layer 1: API to Layer2+ */
   2:layer1/l23_api.c **** 
   3:layer1/l23_api.c **** /* (C) 2010 by Holger Hans Peter Freyther <zecke@selfish.org>
   4:layer1/l23_api.c ****  *
   5:layer1/l23_api.c ****  * All Rights Reserved
   6:layer1/l23_api.c ****  *
   7:layer1/l23_api.c ****  * This program is free software; you can redistribute it and/or modify
   8:layer1/l23_api.c ****  * it under the terms of the GNU General Public License as published by
   9:layer1/l23_api.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:layer1/l23_api.c ****  * (at your option) any later version.
  11:layer1/l23_api.c ****  *
  12:layer1/l23_api.c ****  * This program is distributed in the hope that it will be useful,
  13:layer1/l23_api.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:layer1/l23_api.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:layer1/l23_api.c ****  * GNU General Public License for more details.
  16:layer1/l23_api.c ****  *
  17:layer1/l23_api.c ****  * You should have received a copy of the GNU General Public License along
  18:layer1/l23_api.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:layer1/l23_api.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:layer1/l23_api.c ****  *
  21:layer1/l23_api.c ****  */
  22:layer1/l23_api.c **** 
  23:layer1/l23_api.c **** #define DEBUG
  24:layer1/l23_api.c **** 
  25:layer1/l23_api.c **** #include <stdint.h>
  26:layer1/l23_api.c **** #include <stdio.h>
  27:layer1/l23_api.c **** #include <string.h>
  28:layer1/l23_api.c **** 
  29:layer1/l23_api.c **** #include <debug.h>
  30:layer1/l23_api.c **** #include <byteorder.h>
  31:layer1/l23_api.c **** 
  32:layer1/l23_api.c **** #include <asm/system.h>
  33:layer1/l23_api.c **** 
  34:layer1/l23_api.c **** #include <osmocom/core/msgb.h>
  35:layer1/l23_api.c **** #include <osmocom/gsm/protocol/gsm_04_08.h>
  36:layer1/l23_api.c **** #include <comm/sercomm.h>
  37:layer1/l23_api.c **** 
  38:layer1/l23_api.c **** #include <layer1/sync.h>
  39:layer1/l23_api.c **** #include <layer1/async.h>
  40:layer1/l23_api.c **** #include <layer1/mframe_sched.h>
  41:layer1/l23_api.c **** #include <layer1/prim.h>
  42:layer1/l23_api.c **** #include <layer1/tpu_window.h>
  43:layer1/l23_api.c **** #include <layer1/sched_gsmtime.h>
  44:layer1/l23_api.c **** 
  45:layer1/l23_api.c **** #include <abb/twl3025.h>
  46:layer1/l23_api.c **** #include <rf/trf6151.h>
  47:layer1/l23_api.c **** #include <calypso/sim.h>
  48:layer1/l23_api.c **** #include <calypso/dsp.h>
  49:layer1/l23_api.c **** 
  50:layer1/l23_api.c **** #include <l1ctl_proto.h>
  51:layer1/l23_api.c **** 
  52:layer1/l23_api.c **** /* the size we will allocate struct msgb* for HDLC */
  53:layer1/l23_api.c **** #define L3_MSG_HEAD 4
  54:layer1/l23_api.c **** #define L3_MSG_DATA 200
  55:layer1/l23_api.c **** #define L3_MSG_SIZE (L3_MSG_HEAD + sizeof(struct l1ctl_hdr) + L3_MSG_DATA)
  56:layer1/l23_api.c **** 
  57:layer1/l23_api.c **** void (*l1a_l23_tx_cb)(struct msgb *msg) = NULL;
  58:layer1/l23_api.c **** 
  59:layer1/l23_api.c **** void l1_queue_for_l2(struct msgb *msg)
  60:layer1/l23_api.c **** {
  61:layer1/l23_api.c **** 	if (l1a_l23_tx_cb) {
  62:layer1/l23_api.c **** 		l1a_l23_tx_cb(msg);
  63:layer1/l23_api.c **** 		return;
  64:layer1/l23_api.c **** 	}
  65:layer1/l23_api.c **** 	/* forward via serial for now */
  66:layer1/l23_api.c **** 	sercomm_sendmsg(SC_DLCI_L1A_L23, msg);
  67:layer1/l23_api.c **** }
  68:layer1/l23_api.c **** 
  69:layer1/l23_api.c **** enum mf_type {
  70:layer1/l23_api.c **** 	MFNONE,
  71:layer1/l23_api.c **** 	MF51,
  72:layer1/l23_api.c **** 	MF26ODD,
  73:layer1/l23_api.c **** 	MF26EVEN
  74:layer1/l23_api.c **** };
  75:layer1/l23_api.c **** static uint32_t chan_nr2mf_task_mask(uint8_t chan_nr, uint8_t neigh_mode)
  76:layer1/l23_api.c **** {
  77:layer1/l23_api.c **** 	uint8_t cbits = chan_nr >> 3;
  78:layer1/l23_api.c **** 	uint8_t tn = chan_nr & 0x7;
  79:layer1/l23_api.c **** 	uint8_t lch_idx;
  80:layer1/l23_api.c **** 	enum mframe_task master_task = 0;
  81:layer1/l23_api.c **** 	uint32_t neigh_task = 0;
  82:layer1/l23_api.c **** 	enum mf_type multiframe = 0;
  83:layer1/l23_api.c **** 
  84:layer1/l23_api.c **** 	if (cbits == 0x01) {
  85:layer1/l23_api.c **** 		lch_idx = 0;
  86:layer1/l23_api.c **** 		master_task = (tn & 1) ? MF_TASK_TCH_F_ODD : MF_TASK_TCH_F_EVEN;
  87:layer1/l23_api.c **** 		multiframe = (tn & 1) ? MF26ODD : MF26EVEN;
  88:layer1/l23_api.c **** 	} else if ((cbits & 0x1e) == 0x02) {
  89:layer1/l23_api.c **** 		lch_idx = cbits & 0x1;
  90:layer1/l23_api.c **** 		master_task = MF_TASK_TCH_H_0 + lch_idx;
  91:layer1/l23_api.c **** 		multiframe = (lch_idx & 1) ? MF26ODD : MF26EVEN;
  92:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
  93:layer1/l23_api.c **** 		lch_idx = cbits & 0x3;
  94:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH4_0 + lch_idx;
  95:layer1/l23_api.c **** 		multiframe = MF51;
  96:layer1/l23_api.c **** 	} else if ((cbits & 0x18) == 0x08) {
  97:layer1/l23_api.c **** 		lch_idx = cbits & 0x7;
  98:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH8_0 + lch_idx;
  99:layer1/l23_api.c **** 		multiframe = MF51;
 100:layer1/l23_api.c **** #if 0
 101:layer1/l23_api.c **** 	} else if (cbits == 0x10) {
 102:layer1/l23_api.c **** 		/* FIXME: when to do extended BCCH? */
 103:layer1/l23_api.c **** 		master_task = MF_TASK_BCCH_NORM;
 104:layer1/l23_api.c **** 	} else if (cbits == 0x11 || cbits == 0x12) {
 105:layer1/l23_api.c **** 		/* FIXME: how to decide CCCH norm/extd? */
 106:layer1/l23_api.c **** 		master_task = MF_TASK_BCCH_CCCH;
 107:layer1/l23_api.c **** #endif
 108:layer1/l23_api.c **** 	}
 109:layer1/l23_api.c **** 	switch (neigh_mode) {
 110:layer1/l23_api.c **** 	case NEIGH_MODE_PM:
 111:layer1/l23_api.c **** 		switch (multiframe) {
 112:layer1/l23_api.c **** 		case MF51:
 113:layer1/l23_api.c **** 			neigh_task = (1 << MF_TASK_NEIGH_PM51);
 114:layer1/l23_api.c **** 			break;
 115:layer1/l23_api.c **** 		case MF26EVEN:
 116:layer1/l23_api.c **** 			neigh_task = (1 << MF_TASK_NEIGH_PM26E);
 117:layer1/l23_api.c **** 			break;
 118:layer1/l23_api.c **** 		case MF26ODD:
 119:layer1/l23_api.c **** 			neigh_task = (1 << MF_TASK_NEIGH_PM26O);
 120:layer1/l23_api.c **** 			break;
 121:layer1/l23_api.c **** 		}
 122:layer1/l23_api.c **** 		break;
 123:layer1/l23_api.c **** 	}
 124:layer1/l23_api.c **** 	return (1 << master_task) | neigh_task;
 125:layer1/l23_api.c **** }
 126:layer1/l23_api.c **** 
 127:layer1/l23_api.c **** static int  chan_nr2dchan_type(uint8_t chan_nr)
 128:layer1/l23_api.c **** {
 129:layer1/l23_api.c **** 	uint8_t cbits = chan_nr >> 3;
 130:layer1/l23_api.c **** 
 131:layer1/l23_api.c **** 	if (cbits == 0x01) {
 132:layer1/l23_api.c **** 		return GSM_DCHAN_TCH_F;
 133:layer1/l23_api.c **** 	} else if ((cbits & 0x1e) == 0x02) {
 134:layer1/l23_api.c **** 		return GSM_DCHAN_TCH_H;
 135:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
 136:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_4;
 137:layer1/l23_api.c **** 	} else if ((cbits & 0x18) == 0x08) {
 138:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_8;
 139:layer1/l23_api.c **** 	}
 140:layer1/l23_api.c **** 	return GSM_DCHAN_UNKNOWN;
 141:layer1/l23_api.c **** }
 142:layer1/l23_api.c **** 
 143:layer1/l23_api.c **** static int chan_nr_is_tch(uint8_t chan_nr)
 144:layer1/l23_api.c **** {
 145:layer1/l23_api.c **** 	return ((chan_nr >> 3) == 0x01 ||		/* TCH/F */
 146:layer1/l23_api.c **** 		((chan_nr >> 3) & 0x1e) == 0x02);	/* TCH/H */
 147:layer1/l23_api.c **** }
 148:layer1/l23_api.c **** 
 149:layer1/l23_api.c **** static void audio_set_enabled(uint8_t tch_mode, uint8_t audio_mode)
 150:layer1/l23_api.c **** {
  17              		.loc 1 150 0
  18              		.cfi_startproc
  19              		@ args = 0, pretend = 0, frame = 0
  20              		@ frame_needed = 0, uses_anonymous_args = 0
  21              	.LVL0:
  22 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
  23              	.LCFI0:
  24              		.cfi_def_cfa_offset 12
 151:layer1/l23_api.c **** 	if (tch_mode == GSM48_CMODE_SIGN) {
  25              		.loc 1 151 0
  26 0004 005050E2 		subs	r5, r0, #0
  27              		.cfi_offset 14, -4
  28              		.cfi_offset 5, -8
  29              		.cfi_offset 4, -12
 150:layer1/l23_api.c **** {
  30              		.loc 1 150 0
  31 0008 0140A0E1 		mov	r4, r1
  32              		.loc 1 151 0
  33 000c 0500001A 		bne	.L2
 152:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VUL, 0);
  34              		.loc 1 152 0
  35 0010 040080E2 		add	r0, r0, #4
  36              	.LVL1:
  37 0014 0510A0E1 		mov	r1, r5
  38              	.LVL2:
  39 0018 FEFFFFEB 		bl	twl3025_unit_enable
 153:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VDL, 0);
  40              		.loc 1 153 0
  41 001c 0300A0E3 		mov	r0, #3
  42 0020 0510A0E1 		mov	r1, r5
  43 0024 060000EA 		b	.L3
  44              	.LVL3:
  45              	.L2:
 154:layer1/l23_api.c **** 	} else {
 155:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VUL,
  46              		.loc 1 155 0
  47 0028 0400A0E3 		mov	r0, #4
  48              	.LVL4:
  49 002c 011001E2 		and	r1, r1, #1
  50              	.LVL5:
  51 0030 FEFFFFEB 		bl	twl3025_unit_enable
 156:layer1/l23_api.c **** 		                    !!(audio_mode & AUDIO_TX_MICROPHONE));
 157:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VDL,
  52              		.loc 1 157 0
  53 0034 040014E3 		tst	r4, #4
  54 0038 0300A0E3 		mov	r0, #3
  55 003c 0010A003 		moveq	r1, #0
  56 0040 0110A013 		movne	r1, #1
  57              	.L3:
 158:layer1/l23_api.c **** 		                    !!(audio_mode & AUDIO_RX_SPEAKER));
 159:layer1/l23_api.c **** 	}
 160:layer1/l23_api.c **** }
  58              		.loc 1 160 0
  59 0044 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 157:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VDL,
  60              		.loc 1 157 0
  61 0048 FEFFFFEA 		b	twl3025_unit_enable
  62              		.cfi_endproc
  63              	.LFE61:
  65              		.section	.text.msgb_put,"ax",%progbits
  66              		.align	2
  68              	msgb_put:
  69              	.LFB35:
  70              		.file 2 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
  71              		.loc 2 180 0
  72              		.cfi_startproc
  73              		@ args = 0, pretend = 0, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 0
  75              	.LVL6:
  76              	.LBB175:
  77              	.LBB176:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
  78              		.loc 2 152 0
  79 0000 B433D0E1 		ldrh	r3, [r0, #52]
  80 0004 382090E5 		ldr	r2, [r0, #56]
  81              	.LBE176:
  82              	.LBE175:
  83              		.loc 2 180 0
  84 0008 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  85              	.LCFI1:
  86              		.cfi_def_cfa_offset 16
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
  87              		.loc 2 181 0
  88 000c 3C6090E5 		ldr	r6, [r0, #60]
  89              		.cfi_offset 14, -4
  90              		.cfi_offset 6, -8
  91              		.cfi_offset 5, -12
  92              		.cfi_offset 4, -16
  93              	.LVL7:
  94              	.LBB178:
  95              	.LBB177:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
  96              		.loc 2 152 0
  97 0010 032082E0 		add	r2, r2, r3
  98 0014 022066E0 		rsb	r2, r6, r2
  99              	.LBE177:
 100              	.LBE178:
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 101              		.loc 2 182 0
 102 0018 010052E1 		cmp	r2, r1
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 103              		.loc 2 180 0
 104 001c 0040A0E1 		mov	r4, r0
 105              	.LVL8:
 106 0020 0150A0E1 		mov	r5, r1
 107              		.loc 2 182 0
 108              	.LVL9:
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 109              		.loc 2 183 0
 110 0024 28009FB5 		ldrlt	r0, .L6
 111              	.LVL10:
 112 0028 0410A0B1 		movlt	r1, r4
 113              	.LVL11:
 114 002c 0530A0B1 		movlt	r3, r5
 115 0030 FEFFFFBB 		bllt	osmo_panic
 116              	.LVL12:
 117              	.L5:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 118              		.loc 2 185 0
 119 0034 3C3094E5 		ldr	r3, [r4, #60]
 120 0038 053083E0 		add	r3, r3, r5
 121 003c 3C3084E5 		str	r3, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 122              		.loc 2 186 0
 123 0040 B633D4E1 		ldrh	r3, [r4, #54]
 124 0044 035085E0 		add	r5, r5, r3
 125              	.LVL13:
 126 0048 B653C4E1 		strh	r5, [r4, #54]	@ movhi
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 127              		.loc 2 188 0
 128 004c 0600A0E1 		mov	r0, r6
 129 0050 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 130              	.L7:
 131              		.align	2
 132              	.L6:
 133 0054 00000000 		.word	.LC0
 134              		.cfi_endproc
 135              	.LFE35:
 137              		.section	.text.l1a_l23_rx,"ax",%progbits
 138              		.align	2
 139              		.global	l1a_l23_rx
 141              	l1a_l23_rx:
 142              	.LFB82:
 161:layer1/l23_api.c **** 
 162:layer1/l23_api.c **** struct msgb *l1ctl_msgb_alloc(uint8_t msg_type)
 163:layer1/l23_api.c **** {
 164:layer1/l23_api.c **** 	struct msgb *msg;
 165:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h;
 166:layer1/l23_api.c **** 
 167:layer1/l23_api.c **** 	msg = msgb_alloc_headroom(L3_MSG_SIZE, L3_MSG_HEAD, "l1ctl");
 168:layer1/l23_api.c **** 	if (!msg) {
 169:layer1/l23_api.c **** 		while (1) {
 170:layer1/l23_api.c **** 			puts("OOPS. Out of buffers...\n");
 171:layer1/l23_api.c **** 		}
 172:layer1/l23_api.c **** 
 173:layer1/l23_api.c **** 		return NULL;
 174:layer1/l23_api.c **** 	}
 175:layer1/l23_api.c **** 	l1h = (struct l1ctl_hdr *) msgb_put(msg, sizeof(*l1h));
 176:layer1/l23_api.c **** 	l1h->msg_type = msg_type;
 177:layer1/l23_api.c **** 	l1h->flags = 0;
 178:layer1/l23_api.c **** 
 179:layer1/l23_api.c **** 	msg->l1h = (uint8_t *)l1h;
 180:layer1/l23_api.c **** 
 181:layer1/l23_api.c **** 	return msg;
 182:layer1/l23_api.c **** }
 183:layer1/l23_api.c **** 
 184:layer1/l23_api.c **** struct msgb *l1_create_l2_msg(int msg_type, uint32_t fn, uint16_t snr,
 185:layer1/l23_api.c **** 			      uint16_t arfcn)
 186:layer1/l23_api.c **** {
 187:layer1/l23_api.c **** 	struct l1ctl_info_dl *dl;
 188:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 189:layer1/l23_api.c **** 
 190:layer1/l23_api.c **** 	dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 191:layer1/l23_api.c **** 	dl->frame_nr = htonl(fn);
 192:layer1/l23_api.c **** 	dl->snr = snr;
 193:layer1/l23_api.c **** 	dl->band_arfcn = htons(arfcn);
 194:layer1/l23_api.c **** 
 195:layer1/l23_api.c **** 	return msg;
 196:layer1/l23_api.c **** }
 197:layer1/l23_api.c **** 
 198:layer1/l23_api.c **** /* receive a L1CTL_FBSB_REQ from L23 */
 199:layer1/l23_api.c **** static void l1ctl_rx_fbsb_req(struct msgb *msg)
 200:layer1/l23_api.c **** {
 201:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 202:layer1/l23_api.c **** 	struct l1ctl_fbsb_req *sync_req = (struct l1ctl_fbsb_req *) l1h->data;
 203:layer1/l23_api.c **** 
 204:layer1/l23_api.c **** 	if (sizeof(*sync_req) > msg->len) {
 205:layer1/l23_api.c **** 		printf("Short sync msg. %u\n", msg->len);
 206:layer1/l23_api.c **** 		return;
 207:layer1/l23_api.c **** 	}
 208:layer1/l23_api.c **** 
 209:layer1/l23_api.c **** 	printd("L1CTL_FBSB_REQ (arfcn=%u, flags=0x%x)\n",
 210:layer1/l23_api.c **** 		ntohs(sync_req->band_arfcn), sync_req->flags);
 211:layer1/l23_api.c **** 
 212:layer1/l23_api.c **** 	/* reset scheduler and hardware */
 213:layer1/l23_api.c **** 	l1s_reset();
 214:layer1/l23_api.c **** 
 215:layer1/l23_api.c **** 	/* pre-set the CCCH mode */
 216:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = sync_req->ccch_mode;
 217:layer1/l23_api.c **** 
 218:layer1/l23_api.c **** 	printd("Starting FCCH Recognition\n");
 219:layer1/l23_api.c **** 	l1s_fbsb_req(1, sync_req);
 220:layer1/l23_api.c **** }
 221:layer1/l23_api.c **** 
 222:layer1/l23_api.c **** /* receive a L1CTL_DM_EST_REQ from L23 */
 223:layer1/l23_api.c **** static void l1ctl_rx_dm_est_req(struct msgb *msg)
 224:layer1/l23_api.c **** {
 225:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 226:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 227:layer1/l23_api.c **** 	struct l1ctl_dm_est_req *est_req = (struct l1ctl_dm_est_req *) ul->payload;
 228:layer1/l23_api.c **** 
 229:layer1/l23_api.c **** 	printd("L1CTL_DM_EST_REQ (arfcn=%u, chan_nr=0x%02x, tsc=%u)\n",
 230:layer1/l23_api.c **** 		ntohs(est_req->h0.band_arfcn), ul->chan_nr, est_req->tsc);
 231:layer1/l23_api.c **** 
 232:layer1/l23_api.c **** 	/* disable neighbour cell measurement of C0 TS 0 */
 233:layer1/l23_api.c **** 	mframe_disable(MF_TASK_NEIGH_PM51_C0T0);
 234:layer1/l23_api.c **** 
 235:layer1/l23_api.c **** 	/* configure dedicated channel state */
 236:layer1/l23_api.c **** 	l1s.dedicated.type = chan_nr2dchan_type(ul->chan_nr);
 237:layer1/l23_api.c **** 	l1s.dedicated.tsc  = est_req->tsc;
 238:layer1/l23_api.c **** 	l1s.dedicated.tn   = ul->chan_nr & 0x7;
 239:layer1/l23_api.c **** 	l1s.dedicated.h    = est_req->h;
 240:layer1/l23_api.c **** 
 241:layer1/l23_api.c **** 	if (est_req->h) {
 242:layer1/l23_api.c **** 		int i;
 243:layer1/l23_api.c **** 		l1s.dedicated.h1.hsn  = est_req->h1.hsn;
 244:layer1/l23_api.c **** 		l1s.dedicated.h1.maio = est_req->h1.maio;
 245:layer1/l23_api.c **** 		l1s.dedicated.h1.n    = est_req->h1.n;
 246:layer1/l23_api.c **** 		for (i=0; i<est_req->h1.n; i++)
 247:layer1/l23_api.c **** 			l1s.dedicated.h1.ma[i] = ntohs(est_req->h1.ma[i]);
 248:layer1/l23_api.c **** 	} else {
 249:layer1/l23_api.c **** 		l1s.dedicated.h0.arfcn = ntohs(est_req->h0.band_arfcn);
 250:layer1/l23_api.c **** 	}
 251:layer1/l23_api.c **** 
 252:layer1/l23_api.c **** 	/* TCH config */
 253:layer1/l23_api.c **** 	if (chan_nr_is_tch(ul->chan_nr)) {
 254:layer1/l23_api.c **** 		/* Mode */
 255:layer1/l23_api.c **** 		l1a_tch_mode_set(est_req->tch_mode);
 256:layer1/l23_api.c **** 		l1a_audio_mode_set(est_req->audio_mode);
 257:layer1/l23_api.c **** 
 258:layer1/l23_api.c **** 		/* Sync */
 259:layer1/l23_api.c **** 		l1s.tch_sync = 1;	/* can be set without locking */
 260:layer1/l23_api.c **** 
 261:layer1/l23_api.c **** 		/* Audio path */
 262:layer1/l23_api.c **** 		audio_set_enabled(est_req->tch_mode, est_req->audio_mode);
 263:layer1/l23_api.c **** 	}
 264:layer1/l23_api.c **** 
 265:layer1/l23_api.c **** 	/* figure out which MF tasks to enable */
 266:layer1/l23_api.c **** 	l1a_mftask_set(chan_nr2mf_task_mask(ul->chan_nr, NEIGH_MODE_PM));
 267:layer1/l23_api.c **** }
 268:layer1/l23_api.c **** 
 269:layer1/l23_api.c **** /* receive a L1CTL_DM_FREQ_REQ from L23 */
 270:layer1/l23_api.c **** static void l1ctl_rx_dm_freq_req(struct msgb *msg)
 271:layer1/l23_api.c **** {
 272:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 273:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 274:layer1/l23_api.c **** 	struct l1ctl_dm_freq_req *freq_req =
 275:layer1/l23_api.c **** 			(struct l1ctl_dm_freq_req *) ul->payload;
 276:layer1/l23_api.c **** 
 277:layer1/l23_api.c **** 	printd("L1CTL_DM_FREQ_REQ (arfcn=%u, tsc=%u)\n",
 278:layer1/l23_api.c **** 		ntohs(freq_req->h0.band_arfcn), freq_req->tsc);
 279:layer1/l23_api.c **** 
 280:layer1/l23_api.c **** 	/* configure dedicated channel state */
 281:layer1/l23_api.c **** 	l1s.dedicated.st_tsc  = freq_req->tsc;
 282:layer1/l23_api.c **** 	l1s.dedicated.st_h    = freq_req->h;
 283:layer1/l23_api.c **** 
 284:layer1/l23_api.c **** 	if (freq_req->h) {
 285:layer1/l23_api.c **** 		int i;
 286:layer1/l23_api.c **** 		l1s.dedicated.st_h1.hsn  = freq_req->h1.hsn;
 287:layer1/l23_api.c **** 		l1s.dedicated.st_h1.maio = freq_req->h1.maio;
 288:layer1/l23_api.c **** 		l1s.dedicated.st_h1.n    = freq_req->h1.n;
 289:layer1/l23_api.c **** 		for (i=0; i<freq_req->h1.n; i++)
 290:layer1/l23_api.c **** 			l1s.dedicated.st_h1.ma[i] = ntohs(freq_req->h1.ma[i]);
 291:layer1/l23_api.c **** 	} else {
 292:layer1/l23_api.c **** 		l1s.dedicated.st_h0.arfcn = ntohs(freq_req->h0.band_arfcn);
 293:layer1/l23_api.c **** 	}
 294:layer1/l23_api.c **** 
 295:layer1/l23_api.c **** 	l1a_freq_req(ntohs(freq_req->fn));
 296:layer1/l23_api.c **** }
 297:layer1/l23_api.c **** 
 298:layer1/l23_api.c **** /* receive a L1CTL_CRYPTO_REQ from L23 */
 299:layer1/l23_api.c **** static void l1ctl_rx_crypto_req(struct msgb *msg)
 300:layer1/l23_api.c **** {
 301:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 302:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 303:layer1/l23_api.c **** 	struct l1ctl_crypto_req *cr = (struct l1ctl_crypto_req *) ul->payload;
 304:layer1/l23_api.c **** 	uint8_t key_len = msg->len - sizeof(*l1h) - sizeof(*ul) - sizeof(*cr);
 305:layer1/l23_api.c **** 
 306:layer1/l23_api.c **** 	printd("L1CTL_CRYPTO_REQ (algo=A5/%u, len=%u)\n", cr->algo, key_len);
 307:layer1/l23_api.c **** 
 308:layer1/l23_api.c **** 	if (cr->algo && key_len != 8) {
 309:layer1/l23_api.c **** 		printd("L1CTL_CRYPTO_REQ -> Invalid key\n");
 310:layer1/l23_api.c **** 		return;
 311:layer1/l23_api.c **** 	}
 312:layer1/l23_api.c **** 
 313:layer1/l23_api.c **** 	dsp_load_ciph_param(cr->algo, cr->key);
 314:layer1/l23_api.c **** }
 315:layer1/l23_api.c **** 
 316:layer1/l23_api.c **** /* receive a L1CTL_DM_REL_REQ from L23 */
 317:layer1/l23_api.c **** static void l1ctl_rx_dm_rel_req(struct msgb *msg)
 318:layer1/l23_api.c **** {
 319:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 320:layer1/l23_api.c **** 
 321:layer1/l23_api.c **** 	printd("L1CTL_DM_REL_REQ\n");
 322:layer1/l23_api.c **** 	l1a_mftask_set(0);
 323:layer1/l23_api.c **** 	l1s.dedicated.type = GSM_DCHAN_NONE;
 324:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_MAIN]);
 325:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_SACCH]);
 326:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 327:layer1/l23_api.c **** 	l1a_meas_msgb_set(NULL);
 328:layer1/l23_api.c **** 	dsp_load_ciph_param(0, NULL);
 329:layer1/l23_api.c **** 	l1a_tch_mode_set(GSM48_CMODE_SIGN);
 330:layer1/l23_api.c **** 	audio_set_enabled(GSM48_CMODE_SIGN, 0);
 331:layer1/l23_api.c **** 	l1s.neigh_pm.n = 0;
 332:layer1/l23_api.c **** }
 333:layer1/l23_api.c **** 
 334:layer1/l23_api.c **** /* receive a L1CTL_PARAM_REQ from L23 */
 335:layer1/l23_api.c **** static void l1ctl_rx_param_req(struct msgb *msg)
 336:layer1/l23_api.c **** {
 337:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 338:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 339:layer1/l23_api.c **** 	struct l1ctl_par_req *par_req = (struct l1ctl_par_req *) ul->payload;
 340:layer1/l23_api.c **** 
 341:layer1/l23_api.c **** 	printd("L1CTL_PARAM_REQ (ta=%d, tx_power=%d)\n", par_req->ta,
 342:layer1/l23_api.c **** 		par_req->tx_power);
 343:layer1/l23_api.c **** 
 344:layer1/l23_api.c **** 	l1s.ta = par_req->ta;
 345:layer1/l23_api.c **** 	l1s.tx_power = par_req->tx_power;
 346:layer1/l23_api.c **** }
 347:layer1/l23_api.c **** 
 348:layer1/l23_api.c **** /* receive a L1CTL_RACH_REQ from L23 */
 349:layer1/l23_api.c **** static void l1ctl_rx_rach_req(struct msgb *msg)
 350:layer1/l23_api.c **** {
 351:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 352:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 353:layer1/l23_api.c **** 	struct l1ctl_rach_req *rach_req = (struct l1ctl_rach_req *) ul->payload;
 354:layer1/l23_api.c **** 
 355:layer1/l23_api.c **** 	printd("L1CTL_RACH_REQ (ra=0x%02x, offset=%d combined=%d)\n",
 356:layer1/l23_api.c **** 		rach_req->ra, ntohs(rach_req->offset), rach_req->combined);
 357:layer1/l23_api.c **** 
 358:layer1/l23_api.c **** 	l1a_rach_req(ntohs(rach_req->offset), rach_req->combined,
 359:layer1/l23_api.c **** 		rach_req->ra);
 360:layer1/l23_api.c **** }
 361:layer1/l23_api.c **** 
 362:layer1/l23_api.c **** /* receive a L1CTL_DATA_REQ from L23 */
 363:layer1/l23_api.c **** static void l1ctl_rx_data_req(struct msgb *msg)
 364:layer1/l23_api.c **** {
 365:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 366:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 367:layer1/l23_api.c **** 	struct l1ctl_data_ind *data_ind = (struct l1ctl_data_ind *) ul->payload;
 368:layer1/l23_api.c **** 	struct llist_head *tx_queue;
 369:layer1/l23_api.c **** 
 370:layer1/l23_api.c **** 	printd("L1CTL_DATA_REQ (link_id=0x%02x)\n", ul->link_id);
 371:layer1/l23_api.c **** 
 372:layer1/l23_api.c **** 	msg->l3h = data_ind->data;
 373:layer1/l23_api.c **** 	if (ul->link_id & 0x40) {
 374:layer1/l23_api.c **** 		struct gsm48_hdr *gh = (struct gsm48_hdr *)(data_ind->data + 5);
 375:layer1/l23_api.c **** 		if (gh->proto_discr == GSM48_PDISC_RR
 376:layer1/l23_api.c **** 		 && gh->msg_type == GSM48_MT_RR_MEAS_REP) {
 377:layer1/l23_api.c **** 			printd("updating measurement report\n");
 378:layer1/l23_api.c **** 			l1a_meas_msgb_set(msg);
 379:layer1/l23_api.c **** 			return;
 380:layer1/l23_api.c **** 		}
 381:layer1/l23_api.c **** 		tx_queue = &l1s.tx_queue[L1S_CHAN_SACCH];
 382:layer1/l23_api.c **** 	} else
 383:layer1/l23_api.c **** 		tx_queue = &l1s.tx_queue[L1S_CHAN_MAIN];
 384:layer1/l23_api.c **** 
 385:layer1/l23_api.c **** 	printd("ul=%p, ul->payload=%p, data_ind=%p, data_ind->data=%p l3h=%p\n",
 386:layer1/l23_api.c **** 		ul, ul->payload, data_ind, data_ind->data, msg->l3h);
 387:layer1/l23_api.c **** 
 388:layer1/l23_api.c **** 	l1a_txq_msgb_enq(tx_queue, msg);
 389:layer1/l23_api.c **** }
 390:layer1/l23_api.c **** 
 391:layer1/l23_api.c **** /* receive a L1CTL_PM_REQ from L23 */
 392:layer1/l23_api.c **** static void l1ctl_rx_pm_req(struct msgb *msg)
 393:layer1/l23_api.c **** {
 394:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 395:layer1/l23_api.c **** 	struct l1ctl_pm_req *pm_req = (struct l1ctl_pm_req *) l1h->data;
 396:layer1/l23_api.c **** 
 397:layer1/l23_api.c **** 	switch (pm_req->type) {
 398:layer1/l23_api.c **** 	case 1:
 399:layer1/l23_api.c **** 		l1s.pm.mode = 1;
 400:layer1/l23_api.c **** 		l1s.pm.range.arfcn_start =
 401:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_from);
 402:layer1/l23_api.c **** 		l1s.pm.range.arfcn_next =
 403:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_from);
 404:layer1/l23_api.c **** 		l1s.pm.range.arfcn_end =
 405:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_to);
 406:layer1/l23_api.c **** 		printf("L1CTL_PM_REQ start=%u end=%u\n",
 407:layer1/l23_api.c **** 			l1s.pm.range.arfcn_start, l1s.pm.range.arfcn_end);
 408:layer1/l23_api.c **** 		break;
 409:layer1/l23_api.c **** 	}
 410:layer1/l23_api.c **** 	l1s_reset_hw(); /* must reset, otherwise measurement results are delayed */
 411:layer1/l23_api.c **** 	l1s_pm_test(1, l1s.pm.range.arfcn_next);
 412:layer1/l23_api.c **** }
 413:layer1/l23_api.c **** 
 414:layer1/l23_api.c **** /* Transmit a L1CTL_RESET_IND or L1CTL_RESET_CONF */
 415:layer1/l23_api.c **** void l1ctl_tx_reset(uint8_t msg_type, uint8_t reset_type)
 416:layer1/l23_api.c **** {
 417:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 418:layer1/l23_api.c **** 	struct l1ctl_reset *reset_resp;
 419:layer1/l23_api.c **** 	reset_resp = (struct l1ctl_reset *)
 420:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*reset_resp));
 421:layer1/l23_api.c **** 	reset_resp->type = reset_type;
 422:layer1/l23_api.c **** 
 423:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 424:layer1/l23_api.c **** }
 425:layer1/l23_api.c **** 
 426:layer1/l23_api.c **** /* receive a L1CTL_RESET_REQ from L23 */
 427:layer1/l23_api.c **** static void l1ctl_rx_reset_req(struct msgb *msg)
 428:layer1/l23_api.c **** {
 429:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 430:layer1/l23_api.c **** 	struct l1ctl_reset *reset_req =
 431:layer1/l23_api.c **** 				(struct l1ctl_reset *) l1h->data;
 432:layer1/l23_api.c **** 
 433:layer1/l23_api.c **** 	switch (reset_req->type) {
 434:layer1/l23_api.c **** 	case L1CTL_RES_T_FULL:
 435:layer1/l23_api.c **** 		printf("L1CTL_RESET_REQ: FULL!\n");
 436:layer1/l23_api.c **** 		l1s_reset();
 437:layer1/l23_api.c **** 		l1s_reset_hw();
 438:layer1/l23_api.c **** 		audio_set_enabled(GSM48_CMODE_SIGN, 0);
 439:layer1/l23_api.c **** 		l1ctl_tx_reset(L1CTL_RESET_CONF, reset_req->type);
 440:layer1/l23_api.c **** 		break;
 441:layer1/l23_api.c **** 	case L1CTL_RES_T_SCHED:
 442:layer1/l23_api.c **** 		printf("L1CTL_RESET_REQ: SCHED!\n");
 443:layer1/l23_api.c **** 		l1ctl_tx_reset(L1CTL_RESET_CONF, reset_req->type);
 444:layer1/l23_api.c **** 		sched_gsmtime_reset();
 445:layer1/l23_api.c **** 		break;
 446:layer1/l23_api.c **** 	default:
 447:layer1/l23_api.c **** 		printf("unknown L1CTL_RESET_REQ type\n");
 448:layer1/l23_api.c **** 		break;
 449:layer1/l23_api.c **** 	}
 450:layer1/l23_api.c **** }
 451:layer1/l23_api.c **** 
 452:layer1/l23_api.c **** /* Transmit a L1CTL_CCCH_MODE_CONF */
 453:layer1/l23_api.c **** static void l1ctl_tx_ccch_mode_conf(uint8_t ccch_mode)
 454:layer1/l23_api.c **** {
 455:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_CCCH_MODE_CONF);
 456:layer1/l23_api.c **** 	struct l1ctl_ccch_mode_conf *mode_conf;
 457:layer1/l23_api.c **** 	mode_conf = (struct l1ctl_ccch_mode_conf *)
 458:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 459:layer1/l23_api.c **** 	mode_conf->ccch_mode = ccch_mode;
 460:layer1/l23_api.c **** 
 461:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 462:layer1/l23_api.c **** }
 463:layer1/l23_api.c **** 
 464:layer1/l23_api.c **** /* receive a L1CTL_CCCH_MODE_REQ from L23 */
 465:layer1/l23_api.c **** static void l1ctl_rx_ccch_mode_req(struct msgb *msg)
 466:layer1/l23_api.c **** {
 467:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 468:layer1/l23_api.c **** 	struct l1ctl_ccch_mode_req *ccch_mode_req =
 469:layer1/l23_api.c **** 		(struct l1ctl_ccch_mode_req *) l1h->data;
 470:layer1/l23_api.c **** 	uint8_t ccch_mode = ccch_mode_req->ccch_mode;
 471:layer1/l23_api.c **** 
 472:layer1/l23_api.c **** 	/* pre-set the CCCH mode */
 473:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = ccch_mode;
 474:layer1/l23_api.c **** 
 475:layer1/l23_api.c **** 	/* Update task */
 476:layer1/l23_api.c **** 	mframe_disable(MF_TASK_CCCH_COMB);
 477:layer1/l23_api.c **** 	mframe_disable(MF_TASK_CCCH);
 478:layer1/l23_api.c **** 
 479:layer1/l23_api.c **** 	if (ccch_mode == CCCH_MODE_COMBINED)
 480:layer1/l23_api.c **** 		mframe_enable(MF_TASK_CCCH_COMB);
 481:layer1/l23_api.c **** 	else if (ccch_mode == CCCH_MODE_NON_COMBINED)
 482:layer1/l23_api.c **** 		mframe_enable(MF_TASK_CCCH);
 483:layer1/l23_api.c **** 
 484:layer1/l23_api.c **** 	l1ctl_tx_ccch_mode_conf(ccch_mode);
 485:layer1/l23_api.c **** }
 486:layer1/l23_api.c **** 
 487:layer1/l23_api.c **** /* Transmit a L1CTL_TCH_MODE_CONF */
 488:layer1/l23_api.c **** static void l1ctl_tx_tch_mode_conf(uint8_t tch_mode, uint8_t audio_mode)
 489:layer1/l23_api.c **** {
 490:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_TCH_MODE_CONF);
 491:layer1/l23_api.c **** 	struct l1ctl_tch_mode_conf *mode_conf;
 492:layer1/l23_api.c **** 	mode_conf = (struct l1ctl_tch_mode_conf *)
 493:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 494:layer1/l23_api.c **** 	mode_conf->tch_mode = tch_mode;
 495:layer1/l23_api.c **** 	mode_conf->audio_mode = audio_mode;
 496:layer1/l23_api.c **** 
 497:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 498:layer1/l23_api.c **** }
 499:layer1/l23_api.c **** 
 500:layer1/l23_api.c **** /* receive a L1CTL_TCH_MODE_REQ from L23 */
 501:layer1/l23_api.c **** static void l1ctl_rx_tch_mode_req(struct msgb *msg)
 502:layer1/l23_api.c **** {
 503:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 504:layer1/l23_api.c **** 	struct l1ctl_tch_mode_req *tch_mode_req =
 505:layer1/l23_api.c **** 		(struct l1ctl_tch_mode_req *) l1h->data;
 506:layer1/l23_api.c **** 	uint8_t tch_mode = tch_mode_req->tch_mode;
 507:layer1/l23_api.c **** 	uint8_t audio_mode = tch_mode_req->audio_mode;
 508:layer1/l23_api.c **** 
 509:layer1/l23_api.c **** 	printd("L1CTL_TCH_MODE_REQ (tch_mode=0x%02x audio_mode=0x%02x)\n",
 510:layer1/l23_api.c **** 		tch_mode, audio_mode);
 511:layer1/l23_api.c **** 	tch_mode = l1a_tch_mode_set(tch_mode);
 512:layer1/l23_api.c **** 	audio_mode = l1a_audio_mode_set(audio_mode);
 513:layer1/l23_api.c **** 
 514:layer1/l23_api.c **** 	audio_set_enabled(tch_mode, audio_mode);
 515:layer1/l23_api.c **** 
 516:layer1/l23_api.c **** 	l1s.tch_sync = 1; /* Needed for audio to work */
 517:layer1/l23_api.c **** 
 518:layer1/l23_api.c **** 	l1ctl_tx_tch_mode_conf(tch_mode, audio_mode);
 519:layer1/l23_api.c **** }
 520:layer1/l23_api.c **** 
 521:layer1/l23_api.c **** /* receive a L1CTL_NEIGH_PM_REQ from L23 */
 522:layer1/l23_api.c **** static void l1ctl_rx_neigh_pm_req(struct msgb *msg)
 523:layer1/l23_api.c **** {
 524:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 525:layer1/l23_api.c **** 	struct l1ctl_neigh_pm_req *pm_req =
 526:layer1/l23_api.c **** 		(struct l1ctl_neigh_pm_req *) l1h->data;
 527:layer1/l23_api.c **** 	int i;
 528:layer1/l23_api.c **** 
 529:layer1/l23_api.c **** 	/* reset list in order to prevent race condition */
 530:layer1/l23_api.c **** 	l1s.neigh_pm.n = 0; /* atomic */
 531:layer1/l23_api.c **** 	l1s.neigh_pm.second = 0;
 532:layer1/l23_api.c **** 	/* now reset pointer and fill list */
 533:layer1/l23_api.c **** 	l1s.neigh_pm.pos = 0;
 534:layer1/l23_api.c **** 	l1s.neigh_pm.running = 0;
 535:layer1/l23_api.c **** 	for (i = 0; i < pm_req->n; i++) {
 536:layer1/l23_api.c **** 		l1s.neigh_pm.band_arfcn[i] = ntohs(pm_req->band_arfcn[i]);
 537:layer1/l23_api.c **** 		l1s.neigh_pm.tn[i] = pm_req->tn[i];
 538:layer1/l23_api.c **** 	}
 539:layer1/l23_api.c **** 	printf("L1CTL_NEIGH_PM_REQ new list with %u entries\n", pm_req->n);
 540:layer1/l23_api.c **** 	l1s.neigh_pm.n = pm_req->n; /* atomic */
 541:layer1/l23_api.c **** 
 542:layer1/l23_api.c **** 	/* on C0 enable PM on frame 51 */
 543:layer1/l23_api.c **** 	if (l1s.dedicated.type == GSM_DCHAN_NONE)
 544:layer1/l23_api.c **** 		mframe_enable(MF_TASK_NEIGH_PM51_C0T0);
 545:layer1/l23_api.c **** }
 546:layer1/l23_api.c **** 
 547:layer1/l23_api.c **** /* receive a L1CTL_TRAFFIC_REQ from L23 */
 548:layer1/l23_api.c **** static void l1ctl_rx_traffic_req(struct msgb *msg)
 549:layer1/l23_api.c **** {
 550:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 551:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 552:layer1/l23_api.c **** 	struct l1ctl_traffic_req *tr = (struct l1ctl_traffic_req *) ul->payload;
 553:layer1/l23_api.c **** 	int num = 0;
 554:layer1/l23_api.c **** 
 555:layer1/l23_api.c **** 	/* printd("L1CTL_TRAFFIC_REQ\n"); */ /* Very verbose, can overwelm serial */
 556:layer1/l23_api.c **** 
 557:layer1/l23_api.c **** 	msg->l2h = tr->data;
 558:layer1/l23_api.c **** 
 559:layer1/l23_api.c **** 	num = l1a_txq_msgb_count(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 560:layer1/l23_api.c **** 	if (num >= 4) {
 561:layer1/l23_api.c **** 		printd("dropping traffic frame\n");
 562:layer1/l23_api.c **** 		msgb_free(msg);
 563:layer1/l23_api.c **** 		return;
 564:layer1/l23_api.c **** 	}
 565:layer1/l23_api.c **** 
 566:layer1/l23_api.c **** 	l1a_txq_msgb_enq(&l1s.tx_queue[L1S_CHAN_TRAFFIC], msg);
 567:layer1/l23_api.c **** }
 568:layer1/l23_api.c **** 
 569:layer1/l23_api.c **** static void l1ctl_sim_req(struct msgb *msg)
 570:layer1/l23_api.c **** {
 571:layer1/l23_api.c **** 	uint16_t len = msg->len - sizeof(struct l1ctl_hdr);
 572:layer1/l23_api.c **** 	uint8_t *data = msg->data + sizeof(struct l1ctl_hdr);
 573:layer1/l23_api.c **** 
 574:layer1/l23_api.c **** #if 1 /* for debugging only */
 575:layer1/l23_api.c **** 	{
 576:layer1/l23_api.c **** 		int i;
 577:layer1/l23_api.c **** 		printf("SIM Request (%u): ", len);
 578:layer1/l23_api.c **** 		for (i = 0; i < len; i++)
 579:layer1/l23_api.c **** 			printf("%02x ", data[i]);
 580:layer1/l23_api.c **** 		puts("\n");
 581:layer1/l23_api.c **** 	}
 582:layer1/l23_api.c **** #endif
 583:layer1/l23_api.c **** 
 584:layer1/l23_api.c ****    sim_apdu(len, data);
 585:layer1/l23_api.c **** }
 586:layer1/l23_api.c **** 
 587:layer1/l23_api.c **** static struct llist_head l23_rx_queue = LLIST_HEAD_INIT(l23_rx_queue);
 588:layer1/l23_api.c **** 
 589:layer1/l23_api.c **** /* callback from SERCOMM when L2 sends a message to L1 */
 590:layer1/l23_api.c **** void l1a_l23_rx(uint8_t dlci, struct msgb *msg)
 591:layer1/l23_api.c **** {
 143              		.loc 1 591 0
 144              		.cfi_startproc
 145              		@ args = 0, pretend = 0, frame = 0
 146              		@ frame_needed = 0, uses_anonymous_args = 0
 147              	.LVL14:
 148 0000 10402DE9 		stmfd	sp!, {r4, lr}
 149              	.LCFI2:
 150              		.cfi_def_cfa_offset 8
 151              	.LBB179:
 592:layer1/l23_api.c **** 	unsigned long flags;
 593:layer1/l23_api.c **** 
 594:layer1/l23_api.c **** 	local_firq_save(flags);
 152              		.loc 1 594 0
 153              	@ 594 "layer1/l23_api.c" 1
 154 0004 00400FE1 		mrs	r4, cpsr		@ local_firq_save
 155 0008 C03084E3 		orr	r3, r4, #0xC0
 156 000c 03F021E1 		msr	cpsr_c, r3
 157              	@ 0 "" 2
 158              	.LBE179:
 595:layer1/l23_api.c **** 	msgb_enqueue(&l23_rx_queue, msg);
 159              		.loc 1 595 0
 160 0010 08009FE5 		ldr	r0, .L9
 161              	.LVL15:
 162              		.cfi_offset 14, -4
 163              		.cfi_offset 4, -8
 164 0014 FEFFFFEB 		bl	msgb_enqueue
 165              	.LVL16:
 596:layer1/l23_api.c **** 	local_irq_restore(flags);
 166              		.loc 1 596 0
 167              	@ 596 "layer1/l23_api.c" 1
 168 0018 04F021E1 		msr	cpsr_c, r4		@ local_irq_restore
 169              	
 170              	@ 0 "" 2
 597:layer1/l23_api.c **** }
 171              		.loc 1 597 0
 172 001c 1080BDE8 		ldmfd	sp!, {r4, pc}
 173              	.L10:
 174              		.align	2
 175              	.L9:
 176 0020 00000000 		.word	.LANCHOR0
 177              		.cfi_endproc
 178              	.LFE82:
 180              		.section	.text.l1_queue_for_l2,"ax",%progbits
 181              		.align	2
 182              		.global	l1_queue_for_l2
 184              	l1_queue_for_l2:
 185              	.LFB57:
  60:layer1/l23_api.c **** {
 186              		.loc 1 60 0
 187              		.cfi_startproc
 188              		@ args = 0, pretend = 0, frame = 0
 189              		@ frame_needed = 0, uses_anonymous_args = 0
 190              	.LVL17:
  61:layer1/l23_api.c **** 	if (l1a_l23_tx_cb) {
 191              		.loc 1 61 0
 192 0000 28309FE5 		ldr	r3, .L14
 193 0004 003093E5 		ldr	r3, [r3, #0]
 194 0008 000053E3 		cmp	r3, #0
  60:layer1/l23_api.c **** {
 195              		.loc 1 60 0
 196 000c 04E02DE5 		str	lr, [sp, #-4]!
 197              	.LCFI3:
 198              		.cfi_def_cfa_offset 4
  60:layer1/l23_api.c **** {
 199              		.loc 1 60 0
 200 0010 0010A0E1 		mov	r1, r0
  61:layer1/l23_api.c **** 	if (l1a_l23_tx_cb) {
 201              		.loc 1 61 0
 202 0014 0200000A 		beq	.L12
 203              		.cfi_offset 14, -4
  62:layer1/l23_api.c **** 		l1a_l23_tx_cb(msg);
 204              		.loc 1 62 0
 205 0018 0FE0A0E1 		mov	lr, pc
 206 001c 13FF2FE1 		bx	r3
 207              	.LVL18:
  67:layer1/l23_api.c **** }
 208              		.loc 1 67 0
 209 0020 04F09DE4 		ldr	pc, [sp], #4
 210              	.LVL19:
 211              	.L12:
  66:layer1/l23_api.c **** 	sercomm_sendmsg(SC_DLCI_L1A_L23, msg);
 212              		.loc 1 66 0
 213 0024 0500A0E3 		mov	r0, #5
 214              	.LVL20:
  67:layer1/l23_api.c **** }
 215              		.loc 1 67 0
 216 0028 04E09DE4 		ldr	lr, [sp], #4
  66:layer1/l23_api.c **** 	sercomm_sendmsg(SC_DLCI_L1A_L23, msg);
 217              		.loc 1 66 0
 218 002c FEFFFFEA 		b	sercomm_sendmsg
 219              	.LVL21:
 220              	.L15:
 221              		.align	2
 222              	.L14:
 223 0030 00000000 		.word	.LANCHOR1
 224              		.cfi_endproc
 225              	.LFE57:
 227              		.section	.text.l1ctl_msgb_alloc,"ax",%progbits
 228              		.align	2
 229              		.global	l1ctl_msgb_alloc
 231              	l1ctl_msgb_alloc:
 232              	.LFB62:
 163:layer1/l23_api.c **** {
 233              		.loc 1 163 0
 234              		.cfi_startproc
 235              		@ args = 0, pretend = 0, frame = 0
 236              		@ frame_needed = 0, uses_anonymous_args = 0
 237              	.LVL22:
 238 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 239              	.LCFI4:
 240              		.cfi_def_cfa_offset 12
 241              	.LBB180:
 242              	.LBB181:
 189:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 190:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint8 value to the end of the message
 191:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 192:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 8bit byte to be appended
 193:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 194:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u8(struct msgb *msgb, uint8_t word)
 195:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 196:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 1);
 197:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word & 0xFF;
 198:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 199:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 200:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint16 value to the end of the message
 201:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 202:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 16bit byte to be appended
 203:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 204:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u16(struct msgb *msgb, uint16_t word)
 205:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 206:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 2);
 207:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 8 & 0xFF;
 208:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word & 0xFF;
 209:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 210:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 211:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint32 value to the end of the message
 212:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 213:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 32bit byte to be appended
 214:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 215:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u32(struct msgb *msgb, uint32_t word)
 216:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 217:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 4);
 218:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 24 & 0xFF;
 219:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word >> 16 & 0xFF;
 220:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[2] = word >> 8 & 0xFF;
 221:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[3] = word & 0xFF;
 222:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 223:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 224:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove data from end of message
 225:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 226:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to remove from end
 227:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 228:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_get(struct msgb *msgb, unsigned int len)
 229:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 230:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->data - len;
 231:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_length(msgb) < len)
 232:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "msgb too small to get %u (len %u)\n",
 233:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   len, msgb_length(msgb));
 234:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail -= len;
 235:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 236:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 237:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 238:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from end of message
 239:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 240:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 241:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 242:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_get_u8(struct msgb *msgb)
 243:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 244:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 1);
 245:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 246:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 247:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from end of message
 248:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 249:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 250:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 251:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_get_u16(struct msgb *msgb)
 252:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 253:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 2);
 254:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 255:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 256:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from end of message
 257:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 258:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 259:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 260:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_get_u32(struct msgb *msgb)
 261:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 262:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 4);
 263:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 264:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 265:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 266:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief prepend (push) some data to start of message
 267:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 268:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to pre-pend
 269:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to newly added portion at start of \a msgb
 270:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 271:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further
 272:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * to the front (by \a len bytes), thereby enlarging the message by \a
 273:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes.
 274:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 275:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to the newly added section in the
 276:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * beginning of the message.  It can be used to fill/copy data into it.
 277:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 278:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_push(struct msgb *msgb, unsigned int len)
 279:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 280:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_headroom(msgb) < (int) len)
 281:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough headroom msgb_push (%u < %u)\n",
 282:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_headroom(msgb), len);
 283:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data -= len;
 284:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 285:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data;
 286:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 287:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove (pull) a header from the front of the message buffer
 288:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 289:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of octets to be pulled
 290:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to new start of msgb
 291:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 292:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further back
 293:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * in the message, thereby shrinking the size of the message by \a len
 294:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * bytes.
 295:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 296:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_pull(struct msgb *msgb, unsigned int len)
 297:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 300:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 301:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 302:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from front of message
 303:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 304:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 305:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 306:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_pull_u8(struct msgb *msgb)
 307:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 308:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 1) - 1;
 309:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 310:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 311:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from front of message
 312:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 313:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 314:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 315:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_pull_u16(struct msgb *msgb)
 316:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 317:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 2) - 2;
 318:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 319:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 320:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from front of message
 321:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 322:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 323:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 324:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_pull_u32(struct msgb *msgb)
 325:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 326:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 4) - 4;
 327:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 328:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 329:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 330:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Increase headroom of empty msgb, reducing the tailroom
 331:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 332:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len amount of extra octets to be reserved as headroom
 333:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 334:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function reserves some memory at the beginning of the underlying
 335:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer.  The idea is to reserve space in case further headers
 336:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * have to be pushed to the \ref msgb during further processing.
 337:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 338:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * Calling this function leads to undefined reusults if it is called on
 339:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * a non-empty \ref msgb.
 340:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 341:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_reserve(struct msgb *msg, int len)
 342:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 343:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 344:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 345:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 346:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 347:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given absolute length
 348:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 349:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len new total length of buffer
 350:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 351:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 352:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_trim(struct msgb *msg, int len)
 353:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 354:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (len > msg->data_len)
 355:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		return -1;
 356:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 357:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->len = len;
 358:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail = msg->data + len;
 359:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 360:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return 0;
 361:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 362:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 363:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given layer3 length
 364:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \pram[in] msg message buffer
 365:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] l3len new layer3 length
 366:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 367:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 368:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_l3trim(struct msgb *msg, int l3len)
 369:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 370:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb_trim(msg, (msg->l3h - msg->data) + l3len);
 371:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 372:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 373:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Allocate message buffer with specified headroom
 374:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] size size in bytes, including headroom
 375:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] headroom headroom in bytes
 376:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] name human-readable name
 377:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns allocated message buffer with specified headroom
 378:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 379:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function is a convenience wrapper around \ref msgb_alloc
 380:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * followed by \ref msgb_reserve in order to create a new \ref msgb with
 381:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * user-specified amount of headroom.
 382:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 383:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline struct msgb *msgb_alloc_headroom(int size, int headroom,
 384:../../shared/libosmocore/include/osmocom/core/msgb.h **** 						const char *name)
 385:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 386:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_static_assert(size > headroom, headroom_bigger);
 387:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 388:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct msgb *msg = msgb_alloc(size, name);
 243              		.loc 2 388 0
 244 0004 54109FE5 		ldr	r1, .L19
 245              	.LBE181:
 246              	.LBE180:
 163:layer1/l23_api.c **** {
 247              		.loc 1 163 0
 248 0008 FF5000E2 		and	r5, r0, #255
 249              		.cfi_offset 14, -4
 250              		.cfi_offset 5, -8
 251              		.cfi_offset 4, -12
 252              	.LBB185:
 253              	.LBB184:
 254              		.loc 2 388 0
 255 000c D000A0E3 		mov	r0, #208
 256              	.LVL23:
 257 0010 FEFFFFEB 		bl	msgb_alloc
 258              	.LVL24:
 389:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msg)
 259              		.loc 2 389 0
 260 0014 004050E2 		subs	r4, r0, #0
 261 0018 0D00000A 		beq	.L18
 262              	.LVL25:
 263              	.LBB182:
 264              	.LBB183:
 343:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 265              		.loc 2 343 0
 266 001c 403094E5 		ldr	r3, [r4, #64]
 267 0020 043083E2 		add	r3, r3, #4
 268 0024 403084E5 		str	r3, [r4, #64]
 344:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 269              		.loc 2 344 0
 270 0028 3C3094E5 		ldr	r3, [r4, #60]
 271 002c 043083E2 		add	r3, r3, #4
 272 0030 3C3084E5 		str	r3, [r4, #60]
 273              	.LBE183:
 274              	.LBE182:
 275              	.LBE184:
 276              	.LBE185:
 175:layer1/l23_api.c **** 	l1h = (struct l1ctl_hdr *) msgb_put(msg, sizeof(*l1h));
 277              		.loc 1 175 0
 278 0034 0410A0E3 		mov	r1, #4
 279 0038 FEFFFFEB 		bl	msgb_put
 280              	.LVL26:
 177:layer1/l23_api.c **** 	l1h->flags = 0;
 281              		.loc 1 177 0
 282 003c 0030A0E3 		mov	r3, #0
 176:layer1/l23_api.c **** 	l1h->msg_type = msg_type;
 283              		.loc 1 176 0
 284 0040 0050C0E5 		strb	r5, [r0, #0]
 177:layer1/l23_api.c **** 	l1h->flags = 0;
 285              		.loc 1 177 0
 286 0044 0130C0E5 		strb	r3, [r0, #1]
 179:layer1/l23_api.c **** 	msg->l1h = (uint8_t *)l1h;
 287              		.loc 1 179 0
 288 0048 100084E5 		str	r0, [r4, #16]
 182:layer1/l23_api.c **** }
 289              		.loc 1 182 0
 290 004c 0400A0E1 		mov	r0, r4
 291              	.LVL27:
 292 0050 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 293              	.LVL28:
 294              	.L18:
 170:layer1/l23_api.c **** 			puts("OOPS. Out of buffers...\n");
 295              		.loc 1 170 0 discriminator 1
 296 0054 08009FE5 		ldr	r0, .L19+4
 297 0058 FEFFFFEB 		bl	puts
 298 005c FCFFFFEA 		b	.L18
 299              	.L20:
 300              		.align	2
 301              	.L19:
 302 0060 33000000 		.word	.LC1
 303 0064 39000000 		.word	.LC2
 304              		.cfi_endproc
 305              	.LFE62:
 307              		.section	.text.l1_create_l2_msg,"ax",%progbits
 308              		.align	2
 309              		.global	l1_create_l2_msg
 311              	l1_create_l2_msg:
 312              	.LFB63:
 186:layer1/l23_api.c **** {
 313              		.loc 1 186 0
 314              		.cfi_startproc
 315              		@ args = 0, pretend = 0, frame = 0
 316              		@ frame_needed = 0, uses_anonymous_args = 0
 317              	.LVL29:
 318 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 319              	.LCFI5:
 320              		.cfi_def_cfa_offset 24
 186:layer1/l23_api.c **** {
 321              		.loc 1 186 0
 322 0004 0228A0E1 		mov	r2, r2, asl #16
 323              	.LVL30:
 188:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 324              		.loc 1 188 0
 325 0008 FF0000E2 		and	r0, r0, #255
 326              	.LVL31:
 186:layer1/l23_api.c **** {
 327              		.loc 1 186 0
 328 000c 0368A0E1 		mov	r6, r3, asl #16
 329              		.cfi_offset 14, -4
 330              		.cfi_offset 8, -8
 331              		.cfi_offset 7, -12
 332              		.cfi_offset 6, -16
 333              		.cfi_offset 5, -20
 334              		.cfi_offset 4, -24
 335 0010 0140A0E1 		mov	r4, r1
 336 0014 2258A0E1 		mov	r5, r2, lsr #16
 188:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 337              		.loc 1 188 0
 338 0018 FEFFFFEB 		bl	l1ctl_msgb_alloc
 339              	.LVL32:
 190:layer1/l23_api.c **** 	dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 340              		.loc 1 190 0
 341 001c 0C10A0E3 		mov	r1, #12
 188:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 342              		.loc 1 188 0
 343 0020 0070A0E1 		mov	r7, r0
 344              	.LVL33:
 190:layer1/l23_api.c **** 	dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 345              		.loc 1 190 0
 346 0024 FEFFFFEB 		bl	msgb_put
 347              	.LVL34:
 348              	.LBB186:
 349              	.LBB187:
 350              	.LBB188:
 351              		.file 3 "include/asm/swab.h"
   1:include/asm/swab.h **** /*
   2:include/asm/swab.h ****  *  arch/arm/include/asm/byteorder.h
   3:include/asm/swab.h ****  *
   4:include/asm/swab.h ****  * ARM Endian-ness.  In little endian mode, the data bus is connected such
   5:include/asm/swab.h ****  * that byte accesses appear as:
   6:include/asm/swab.h ****  *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
   7:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
   8:include/asm/swab.h ****  *  d0...d31
   9:include/asm/swab.h ****  *
  10:include/asm/swab.h ****  * When in big endian mode, byte accesses appear as:
  11:include/asm/swab.h ****  *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
  12:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
  13:include/asm/swab.h ****  *  d0...d31
  14:include/asm/swab.h ****  */
  15:include/asm/swab.h **** #ifndef __ASM_ARM_SWAB_H
  16:include/asm/swab.h **** #define __ASM_ARM_SWAB_H
  17:include/asm/swab.h **** 
  18:include/asm/swab.h **** #include <stdint.h>
  19:include/asm/swab.h **** #include <defines.h>
  20:include/asm/swab.h **** 
  21:include/asm/swab.h **** static inline uint32_t __arch_swab32(uint32_t x)
  22:include/asm/swab.h **** {
  23:include/asm/swab.h **** 	uint32_t t;
  24:include/asm/swab.h **** 
  25:include/asm/swab.h **** #ifndef __thumb__
  26:include/asm/swab.h **** 	if (!__builtin_constant_p(x)) {
  27:include/asm/swab.h **** 		/*
  28:include/asm/swab.h **** 		 * The compiler needs a bit of a hint here to always do the
  29:include/asm/swab.h **** 		 * right thing and not screw it up to different degrees
  30:include/asm/swab.h **** 		 * depending on the gcc version.
  31:include/asm/swab.h **** 		 */
  32:include/asm/swab.h **** 		asm ("eor\t%0, %1, %1, ror #16" : "=r" (t) : "r" (x));
 352              		.loc 3 32 0
 353              	@ 32 "include/asm/swab.h" 1
 354 0028 643824E0 		eor	r3, r4, r4, ror #16
 355              	@ 0 "" 2
 356              	.LVL35:
  33:include/asm/swab.h **** 	} else
  34:include/asm/swab.h **** #endif
  35:include/asm/swab.h **** 		t = x ^ ((x << 16) | (x >> 16)); /* eor r1,r0,r0,ror #16 */
  36:include/asm/swab.h **** 
  37:include/asm/swab.h **** 	x = (x << 24) | (x >> 8);		/* mov r0,r0,ror #8      */
  38:include/asm/swab.h **** 	t &= ~0x00FF0000;			/* bic r1,r1,#0x00FF0000 */
 357              		.loc 3 38 0
 358 002c FF38C3E3 		bic	r3, r3, #16711680
 359              	.LVL36:
  39:include/asm/swab.h **** 	x ^= (t >> 8);				/* eor r0,r0,r1,lsr #8   */
 360              		.loc 3 39 0
 361 0030 2334A0E1 		mov	r3, r3, lsr #8
 362              	.LVL37:
 363 0034 644423E0 		eor	r4, r3, r4, ror #8
 364              	.LVL38:
 365              	.LBE188:
 366              	.LBE187:
 367              	.LBE186:
 186:layer1/l23_api.c **** {
 368              		.loc 1 186 0
 369 0038 2688A0E1 		mov	r8, r6, lsr #16
 370              	.LBB189:
 371              	.LBB190:
 372              		.file 4 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
 373              		.loc 4 51 0
 374 003c 266CA0E1 		mov	r6, r6, lsr #24
 375              	.LBE190:
 376              	.LBE189:
 191:layer1/l23_api.c **** 	dl->frame_nr = htonl(fn);
 377              		.loc 1 191 0
 378 0040 2434A0E1 		mov	r3, r4, lsr #8
 379              	.LBB192:
 380              	.LBB191:
 381              		.loc 4 51 0
 382 0044 088486E1 		orr	r8, r6, r8, asl #8
 383              	.LBE191:
 384              	.LBE192:
 191:layer1/l23_api.c **** 	dl->frame_nr = htonl(fn);
 385              		.loc 1 191 0
 386 0048 0440C0E5 		strb	r4, [r0, #4]
 387 004c 0530C0E5 		strb	r3, [r0, #5]
 193:layer1/l23_api.c **** 	dl->band_arfcn = htons(arfcn);
 388              		.loc 1 193 0
 389 0050 0280C0E5 		strb	r8, [r0, #2]
 191:layer1/l23_api.c **** 	dl->frame_nr = htonl(fn);
 390              		.loc 1 191 0
 391 0054 2438A0E1 		mov	r3, r4, lsr #16
 193:layer1/l23_api.c **** 	dl->band_arfcn = htons(arfcn);
 392              		.loc 1 193 0
 393 0058 2884A0E1 		mov	r8, r8, lsr #8
 191:layer1/l23_api.c **** 	dl->frame_nr = htonl(fn);
 394              		.loc 1 191 0
 395 005c 244CA0E1 		mov	r4, r4, lsr #24
 396              	.LVL39:
 397 0060 0630C0E5 		strb	r3, [r0, #6]
 398 0064 0740C0E5 		strb	r4, [r0, #7]
 192:layer1/l23_api.c **** 	dl->snr = snr;
 399              		.loc 1 192 0
 400 0068 0950C0E5 		strb	r5, [r0, #9]
 193:layer1/l23_api.c **** 	dl->band_arfcn = htons(arfcn);
 401              		.loc 1 193 0
 402 006c 0380C0E5 		strb	r8, [r0, #3]
 196:layer1/l23_api.c **** }
 403              		.loc 1 196 0
 404 0070 0700A0E1 		mov	r0, r7
 405              	.LVL40:
 406 0074 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 407              		.cfi_endproc
 408              	.LFE63:
 410              		.section	.text.l1ctl_tx_reset,"ax",%progbits
 411              		.align	2
 412              		.global	l1ctl_tx_reset
 414              	l1ctl_tx_reset:
 415              	.LFB73:
 416:layer1/l23_api.c **** {
 416              		.loc 1 416 0
 417              		.cfi_startproc
 418              		@ args = 0, pretend = 0, frame = 0
 419              		@ frame_needed = 0, uses_anonymous_args = 0
 420              	.LVL41:
 421 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 422              	.LCFI6:
 423              		.cfi_def_cfa_offset 12
 416:layer1/l23_api.c **** {
 424              		.loc 1 416 0
 425 0004 FF0000E2 		and	r0, r0, #255
 426              	.LVL42:
 427 0008 FF5001E2 		and	r5, r1, #255
 428              		.cfi_offset 14, -4
 429              		.cfi_offset 5, -8
 430              		.cfi_offset 4, -12
 417:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 431              		.loc 1 417 0
 432 000c FEFFFFEB 		bl	l1ctl_msgb_alloc
 433              	.LVL43:
 420:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*reset_resp));
 434              		.loc 1 420 0
 435 0010 0410A0E3 		mov	r1, #4
 417:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 436              		.loc 1 417 0
 437 0014 0040A0E1 		mov	r4, r0
 438              	.LVL44:
 420:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*reset_resp));
 439              		.loc 1 420 0
 440 0018 FEFFFFEB 		bl	msgb_put
 441              	.LVL45:
 421:layer1/l23_api.c **** 	reset_resp->type = reset_type;
 442              		.loc 1 421 0
 443 001c 0050C0E5 		strb	r5, [r0, #0]
 423:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 444              		.loc 1 423 0
 445 0020 0400A0E1 		mov	r0, r4
 446              	.LVL46:
 424:layer1/l23_api.c **** }
 447              		.loc 1 424 0
 448 0024 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 423:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 449              		.loc 1 423 0
 450 0028 FEFFFFEA 		b	l1_queue_for_l2
 451              		.cfi_endproc
 452              	.LFE73:
 454              		.section	.text.l1a_l23_handler,"ax",%progbits
 455              		.align	2
 456              		.global	l1a_l23_handler
 458              	l1a_l23_handler:
 459              	.LFB83:
 598:layer1/l23_api.c **** 
 599:layer1/l23_api.c **** void l1a_l23_handler(void)
 600:layer1/l23_api.c **** {
 460              		.loc 1 600 0
 461              		.cfi_startproc
 462              		@ args = 0, pretend = 0, frame = 0
 463              		@ frame_needed = 0, uses_anonymous_args = 0
 464 0000 F3412DE9 		stmfd	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 465              	.LCFI7:
 466              		.cfi_def_cfa_offset 32
 467              	.LBB266:
 601:layer1/l23_api.c **** 	struct msgb *msg;
 602:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h;
 603:layer1/l23_api.c **** 	unsigned long flags;
 604:layer1/l23_api.c **** 
 605:layer1/l23_api.c **** 	local_firq_save(flags);
 468              		.loc 1 605 0
 469              	@ 605 "layer1/l23_api.c" 1
 470 0004 00400FE1 		mrs	r4, cpsr		@ local_firq_save
 471 0008 C03084E3 		orr	r3, r4, #0xC0
 472 000c 03F021E1 		msr	cpsr_c, r3
 473              	@ 0 "" 2
 474              	.LBE266:
 606:layer1/l23_api.c **** 	msg = msgb_dequeue(&l23_rx_queue);
 475              		.loc 1 606 0
 476 0010 C0089FE5 		ldr	r0, .L93
 477              		.cfi_offset 14, -4
 478              		.cfi_offset 8, -8
 479              		.cfi_offset 7, -12
 480              		.cfi_offset 6, -16
 481              		.cfi_offset 5, -20
 482              		.cfi_offset 4, -24
 483              		.cfi_offset 1, -28
 484              		.cfi_offset 0, -32
 485 0014 FEFFFFEB 		bl	msgb_dequeue
 486 0018 0060A0E1 		mov	r6, r0
 487              	.LVL47:
 607:layer1/l23_api.c **** 	local_irq_restore(flags);
 488              		.loc 1 607 0
 489              	@ 607 "layer1/l23_api.c" 1
 490 001c 04F021E1 		msr	cpsr_c, r4		@ local_irq_restore
 491              	
 492              	@ 0 "" 2
 608:layer1/l23_api.c **** 	if (!msg)
 493              		.loc 1 608 0
 494 0020 000050E3 		cmp	r0, #0
 495 0024 2902000A 		beq	.L23
 609:layer1/l23_api.c **** 		return;
 610:layer1/l23_api.c **** 
 611:layer1/l23_api.c **** 	l1h = (struct l1ctl_hdr *) msg->data;
 612:layer1/l23_api.c **** 
 613:layer1/l23_api.c **** #if 0
 614:layer1/l23_api.c **** 	{
 615:layer1/l23_api.c **** 		int i;
 616:layer1/l23_api.c **** 		printf("l1a_l23_rx_cb (%u): ", msg->len);
 617:layer1/l23_api.c **** 		for (i = 0; i < msg->len; i++)
 618:layer1/l23_api.c **** 			printf("%02x ", msg->data[i]);
 619:layer1/l23_api.c **** 		puts("\n");
 620:layer1/l23_api.c **** 	}
 621:layer1/l23_api.c **** #endif
 622:layer1/l23_api.c **** 
 623:layer1/l23_api.c **** 	msg->l1h = msg->data;
 624:layer1/l23_api.c **** 
 625:layer1/l23_api.c **** 	if (sizeof(*l1h) > msg->len) {
 496              		.loc 1 625 0
 497 0028 B613D0E1 		ldrh	r1, [r0, #54]
 611:layer1/l23_api.c **** 	l1h = (struct l1ctl_hdr *) msg->data;
 498              		.loc 1 611 0
 499 002c 404090E5 		ldr	r4, [r0, #64]
 500              	.LVL48:
 501              		.loc 1 625 0
 502 0030 030051E3 		cmp	r1, #3
 623:layer1/l23_api.c **** 	msg->l1h = msg->data;
 503              		.loc 1 623 0
 504 0034 104080E5 		str	r4, [r0, #16]
 626:layer1/l23_api.c **** 		printf("l1a_l23_cb: Short message. %u\n", msg->len);
 505              		.loc 1 626 0
 506 0038 9C089F95 		ldrls	r0, .L93+4
 507              	.LVL49:
 625:layer1/l23_api.c **** 	if (sizeof(*l1h) > msg->len) {
 508              		.loc 1 625 0
 509 003c 2300009A 		bls	.L88
 627:layer1/l23_api.c **** 		goto exit_msgbfree;
 628:layer1/l23_api.c **** 	}
 629:layer1/l23_api.c **** 
 630:layer1/l23_api.c **** 	switch (l1h->msg_type) {
 510              		.loc 1 630 0
 511 0040 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 512 0044 013043E2 		sub	r3, r3, #1
 513 0048 1B0053E3 		cmp	r3, #27
 514 004c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 515 0050 1A0200EA 		b	.L26
 516              	.L42:
 517 0054 C4000000 		.word	.L27
 518 0058 C0080000 		.word	.L26
 519 005c C0080000 		.word	.L26
 520 0060 F4040000 		.word	.L28
 521 0064 2C010000 		.word	.L29
 522 0068 54050000 		.word	.L30
 523 006c C0080000 		.word	.L26
 524 0070 DC050000 		.word	.L31
 525 0074 C0080000 		.word	.L26
 526 0078 C0080000 		.word	.L26
 527 007c C0080000 		.word	.L26
 528 0080 C0080000 		.word	.L26
 529 0084 7C060000 		.word	.L32
 530 0088 C0080000 		.word	.L26
 531 008c C0080000 		.word	.L26
 532 0090 E8060000 		.word	.L33
 533 0094 C0080000 		.word	.L26
 534 0098 3C030000 		.word	.L34
 535 009c A0030000 		.word	.L35
 536 00a0 D0030000 		.word	.L36
 537 00a4 B8040000 		.word	.L37
 538 00a8 6C080000 		.word	.L38
 539 00ac C0080000 		.word	.L26
 540 00b0 40070000 		.word	.L39
 541 00b4 C0080000 		.word	.L26
 542 00b8 B0070000 		.word	.L40
 543 00bc C0080000 		.word	.L26
 544 00c0 3C080000 		.word	.L41
 545              	.L27:
 546              	.LVL50:
 547              	.LBB267:
 548              	.LBB268:
 204:layer1/l23_api.c **** 	if (sizeof(*sync_req) > msg->len) {
 549              		.loc 1 204 0
 550 00c4 0C0051E3 		cmp	r1, #12
 551 00c8 0200008A 		bhi	.L43
 205:layer1/l23_api.c **** 		printf("Short sync msg. %u\n", msg->len);
 552              		.loc 1 205 0
 553 00cc 0C089FE5 		ldr	r0, .L93+8
 554              	.LVL51:
 555              	.L88:
 556 00d0 FEFFFFEB 		bl	printf
 557              	.LVL52:
 558 00d4 F90100EA 		b	.L26
 559              	.LVL53:
 560              	.L43:
 202:layer1/l23_api.c **** 	struct l1ctl_fbsb_req *sync_req = (struct l1ctl_fbsb_req *) l1h->data;
 561              		.loc 1 202 0
 562 00d8 045084E2 		add	r5, r4, #4
 209:layer1/l23_api.c **** 	printd("L1CTL_FBSB_REQ (arfcn=%u, flags=0x%x)\n",
 563              		.loc 1 209 0
 564 00dc 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 565 00e0 0110D5E5 		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 566 00e4 011483E1 		orr	r1, r3, r1, asl #8
 567              	.LVL54:
 568              	.LBB269:
 569              	.LBB270:
 570              		.loc 4 51 0
 571 00e8 2134A0E1 		mov	r3, r1, lsr #8
 572 00ec 011483E1 		orr	r1, r3, r1, asl #8
 573              	.LVL55:
 574              	.LBE270:
 575              	.LBE269:
 209:layer1/l23_api.c **** 	printd("L1CTL_FBSB_REQ (arfcn=%u, flags=0x%x)\n",
 576              		.loc 1 209 0
 577 00f0 0118A0E1 		mov	r1, r1, asl #16
 578 00f4 2118A0E1 		mov	r1, r1, lsr #16
 579 00f8 0920D5E5 		ldrb	r2, [r5, #9]	@ zero_extendqisi2
 580 00fc E0079FE5 		ldr	r0, .L93+12
 581 0100 FEFFFFEB 		bl	printf
 213:layer1/l23_api.c **** 	l1s_reset();
 582              		.loc 1 213 0
 583 0104 FEFFFFEB 		bl	l1s_reset
 216:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = sync_req->ccch_mode;
 584              		.loc 1 216 0
 585 0108 0B20D5E5 		ldrb	r2, [r5, #11]	@ zero_extendqisi2
 586 010c D4379FE5 		ldr	r3, .L93+16
 218:layer1/l23_api.c **** 	printd("Starting FCCH Recognition\n");
 587              		.loc 1 218 0
 588 0110 D4079FE5 		ldr	r0, .L93+20
 216:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = sync_req->ccch_mode;
 589              		.loc 1 216 0
 590 0114 1B20C3E5 		strb	r2, [r3, #27]
 218:layer1/l23_api.c **** 	printd("Starting FCCH Recognition\n");
 591              		.loc 1 218 0
 592 0118 FEFFFFEB 		bl	puts
 219:layer1/l23_api.c **** 	l1s_fbsb_req(1, sync_req);
 593              		.loc 1 219 0
 594 011c 0100A0E3 		mov	r0, #1
 595 0120 0510A0E1 		mov	r1, r5
 596 0124 FEFFFFEB 		bl	l1s_fbsb_req
 597 0128 E40100EA 		b	.L26
 598              	.LVL56:
 599              	.L29:
 600              	.LBE268:
 601              	.LBE267:
 602              	.LBB271:
 603              	.LBB272:
 226:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 604              		.loc 1 226 0
 605 012c 047084E2 		add	r7, r4, #4
 606              	.LVL57:
 227:layer1/l23_api.c **** 	struct l1ctl_dm_est_req *est_req = (struct l1ctl_dm_est_req *) ul->payload;
 607              		.loc 1 227 0
 608 0130 045087E2 		add	r5, r7, #4
 609              	.LVL58:
 229:layer1/l23_api.c **** 	printd("L1CTL_DM_EST_REQ (arfcn=%u, chan_nr=0x%02x, tsc=%u)\n",
 610              		.loc 1 229 0
 611 0134 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 612 0138 0310D5E5 		ldrb	r1, [r5, #3]	@ zero_extendqisi2
 613 013c 011483E1 		orr	r1, r3, r1, asl #8
 614              	.LVL59:
 615              	.LBB273:
 616              	.LBB274:
 617              		.loc 4 51 0
 618 0140 2134A0E1 		mov	r3, r1, lsr #8
 619 0144 011483E1 		orr	r1, r3, r1, asl #8
 620              	.LVL60:
 621              	.LBE274:
 622              	.LBE273:
 229:layer1/l23_api.c **** 	printd("L1CTL_DM_EST_REQ (arfcn=%u, chan_nr=0x%02x, tsc=%u)\n",
 623              		.loc 1 229 0
 624 0148 0118A0E1 		mov	r1, r1, asl #16
 625 014c 0420D4E5 		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 626 0150 2118A0E1 		mov	r1, r1, lsr #16
 627 0154 0430D7E5 		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 628 0158 90079FE5 		ldr	r0, .L93+24
 629 015c FEFFFFEB 		bl	printf
 233:layer1/l23_api.c **** 	mframe_disable(MF_TASK_NEIGH_PM51_C0T0);
 630              		.loc 1 233 0
 631 0160 1400A0E3 		mov	r0, #20
 632 0164 FEFFFFEB 		bl	mframe_disable
 633              	.LVL61:
 634              	.LBB275:
 635              	.LBB276:
 129:layer1/l23_api.c **** 	uint8_t cbits = chan_nr >> 3;
 636              		.loc 1 129 0
 637 0168 0420D4E5 		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 638 016c A221A0E1 		mov	r2, r2, lsr #3
 639              	.LVL62:
 131:layer1/l23_api.c **** 	if (cbits == 0x01) {
 640              		.loc 1 131 0
 641 0170 010052E3 		cmp	r2, #1
 132:layer1/l23_api.c **** 		return GSM_DCHAN_TCH_F;
 642              		.loc 1 132 0
 643 0174 0420A003 		moveq	r2, #4
 644              	.LVL63:
 131:layer1/l23_api.c **** 	if (cbits == 0x01) {
 645              		.loc 1 131 0
 646 0178 0B00000A 		beq	.L44
 133:layer1/l23_api.c **** 	} else if ((cbits & 0x1e) == 0x02) {
 647              		.loc 1 133 0
 648 017c 1E3002E2 		and	r3, r2, #30
 649 0180 020053E3 		cmp	r3, #2
 134:layer1/l23_api.c **** 		return GSM_DCHAN_TCH_H;
 650              		.loc 1 134 0
 651 0184 0320A003 		moveq	r2, #3
 133:layer1/l23_api.c **** 	} else if ((cbits & 0x1e) == 0x02) {
 652              		.loc 1 133 0
 653 0188 0700000A 		beq	.L44
 135:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
 654              		.loc 1 135 0
 655 018c 1C3002E2 		and	r3, r2, #28
 656 0190 040053E3 		cmp	r3, #4
 136:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_4;
 657              		.loc 1 136 0
 658 0194 0120A003 		moveq	r2, #1
 135:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
 659              		.loc 1 135 0
 660 0198 0300000A 		beq	.L44
 137:layer1/l23_api.c **** 	} else if ((cbits & 0x18) == 0x08) {
 661              		.loc 1 137 0
 662 019c 182002E2 		and	r2, r2, #24
 138:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_8;
 663              		.loc 1 138 0
 664 01a0 080052E3 		cmp	r2, #8
 665 01a4 0520A013 		movne	r2, #5
 666 01a8 0220A003 		moveq	r2, #2
 667              	.L44:
 668              	.LBE276:
 669              	.LBE275:
 236:layer1/l23_api.c **** 	l1s.dedicated.type = chan_nr2dchan_type(ul->chan_nr);
 670              		.loc 1 236 0
 671 01ac 34379FE5 		ldr	r3, .L93+16
 672 01b0 082B83E5 		str	r2, [r3, #2824]
 237:layer1/l23_api.c **** 	l1s.dedicated.tsc  = est_req->tsc;
 673              		.loc 1 237 0
 674 01b4 0420D7E5 		ldrb	r2, [r7, #4]	@ zero_extendqisi2
 675 01b8 0D2BC3E5 		strb	r2, [r3, #2829]
 238:layer1/l23_api.c **** 	l1s.dedicated.tn   = ul->chan_nr & 0x7;
 676              		.loc 1 238 0
 677 01bc 0420D4E5 		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 678 01c0 072002E2 		and	r2, r2, #7
 679 01c4 0E2BC3E5 		strb	r2, [r3, #2830]
 239:layer1/l23_api.c **** 	l1s.dedicated.h    = est_req->h;
 680              		.loc 1 239 0
 681 01c8 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 682 01cc 0F2BC3E5 		strb	r2, [r3, #2831]
 241:layer1/l23_api.c **** 	if (est_req->h) {
 683              		.loc 1 241 0
 684 01d0 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 685 01d4 000052E3 		cmp	r2, #0
 686 01d8 1500000A 		beq	.L45
 687              	.LBB277:
 243:layer1/l23_api.c **** 		l1s.dedicated.h1.hsn  = est_req->h1.hsn;
 688              		.loc 1 243 0
 689 01dc 0220D5E5 		ldrb	r2, [r5, #2]	@ zero_extendqisi2
 690 01e0 102BC3E5 		strb	r2, [r3, #2832]
 244:layer1/l23_api.c **** 		l1s.dedicated.h1.maio = est_req->h1.maio;
 691              		.loc 1 244 0
 692 01e4 0320D5E5 		ldrb	r2, [r5, #3]	@ zero_extendqisi2
 693 01e8 112BC3E5 		strb	r2, [r3, #2833]
 245:layer1/l23_api.c **** 		l1s.dedicated.h1.n    = est_req->h1.n;
 694              		.loc 1 245 0
 695 01ec 0420D5E5 		ldrb	r2, [r5, #4]	@ zero_extendqisi2
 696 01f0 122BC3E5 		strb	r2, [r3, #2834]
 697              	.LVL64:
 698 01f4 F8269FE5 		ldr	r2, .L93+28
 246:layer1/l23_api.c **** 		for (i=0; i<est_req->h1.n; i++)
 699              		.loc 1 246 0
 700 01f8 0030A0E3 		mov	r3, #0
 701 01fc 080000EA 		b	.L46
 702              	.LVL65:
 703              	.L47:
 247:layer1/l23_api.c **** 			l1s.dedicated.h1.ma[i] = ntohs(est_req->h1.ma[i]);
 704              		.loc 1 247 0
 705 0200 020083E2 		add	r0, r3, #2
 706 0204 800085E0 		add	r0, r5, r0, asl #1
 707 0208 0210D0E5 		ldrb	r1, [r0, #2]	@ zero_extendqisi2
 708 020c 0300D0E5 		ldrb	r0, [r0, #3]	@ zero_extendqisi2
 709 0210 001481E1 		orr	r1, r1, r0, asl #8
 710              	.LVL66:
 711              	.LBB278:
 712              	.LBB279:
 713              		.loc 4 51 0
 714 0214 2104A0E1 		mov	r0, r1, lsr #8
 715 0218 011480E1 		orr	r1, r0, r1, asl #8
 716              	.LVL67:
 717              	.LBE279:
 718              	.LBE278:
 247:layer1/l23_api.c **** 			l1s.dedicated.h1.ma[i] = ntohs(est_req->h1.ma[i]);
 719              		.loc 1 247 0
 720 021c B210E2E1 		strh	r1, [r2, #2]!	@ movhi
 246:layer1/l23_api.c **** 		for (i=0; i<est_req->h1.n; i++)
 721              		.loc 1 246 0
 722 0220 013083E2 		add	r3, r3, #1
 723              	.LVL68:
 724              	.L46:
 725 0224 0410D5E5 		ldrb	r1, [r5, #4]	@ zero_extendqisi2
 726 0228 010053E1 		cmp	r3, r1
 727 022c F3FFFFBA 		blt	.L47
 728 0230 060000EA 		b	.L48
 729              	.LVL69:
 730              	.L45:
 731              	.LBE277:
 249:layer1/l23_api.c **** 		l1s.dedicated.h0.arfcn = ntohs(est_req->h0.band_arfcn);
 732              		.loc 1 249 0
 733 0234 0310D5E5 		ldrb	r1, [r5, #3]	@ zero_extendqisi2
 734 0238 0220D5E5 		ldrb	r2, [r5, #2]	@ zero_extendqisi2
 735 023c 012482E1 		orr	r2, r2, r1, asl #8
 736              	.LVL70:
 737              	.LBB280:
 738              	.LBB281:
 739              		.loc 4 51 0
 740 0240 2214A0E1 		mov	r1, r2, lsr #8
 741 0244 022481E1 		orr	r2, r1, r2, asl #8
 742              	.LVL71:
 743              	.LBE281:
 744              	.LBE280:
 249:layer1/l23_api.c **** 		l1s.dedicated.h0.arfcn = ntohs(est_req->h0.band_arfcn);
 745              		.loc 1 249 0
 746 0248 B11EA0E3 		mov	r1, #2832
 747 024c B12083E1 		strh	r2, [r3, r1]	@ movhi
 748              	.L48:
 749              	.LVL72:
 750              	.LBB282:
 751              	.LBB283:
 145:layer1/l23_api.c **** 	return ((chan_nr >> 3) == 0x01 ||		/* TCH/F */
 752              		.loc 1 145 0
 753 0250 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 754 0254 A331A0E1 		mov	r3, r3, lsr #3
 755 0258 010053E3 		cmp	r3, #1
 756 025c 0200000A 		beq	.L49
 146:layer1/l23_api.c **** 		((chan_nr >> 3) & 0x1e) == 0x02);	/* TCH/H */
 757              		.loc 1 146 0
 758 0260 1E3003E2 		and	r3, r3, #30
 145:layer1/l23_api.c **** 	return ((chan_nr >> 3) == 0x01 ||		/* TCH/F */
 759              		.loc 1 145 0
 760 0264 020053E3 		cmp	r3, #2
 761 0268 0900001A 		bne	.L50
 762              	.L49:
 763              	.LBE283:
 764              	.LBE282:
 255:layer1/l23_api.c **** 		l1a_tch_mode_set(est_req->tch_mode);
 765              		.loc 1 255 0
 766 026c 8600D5E5 		ldrb	r0, [r5, #134]	@ zero_extendqisi2
 767 0270 FEFFFFEB 		bl	l1a_tch_mode_set
 768              	.LVL73:
 256:layer1/l23_api.c **** 		l1a_audio_mode_set(est_req->audio_mode);
 769              		.loc 1 256 0
 770 0274 8700D5E5 		ldrb	r0, [r5, #135]	@ zero_extendqisi2
 771 0278 FEFFFFEB 		bl	l1a_audio_mode_set
 259:layer1/l23_api.c **** 		l1s.tch_sync = 1;	/* can be set without locking */
 772              		.loc 1 259 0
 773 027c 64369FE5 		ldr	r3, .L93+16
 774 0280 0120A0E3 		mov	r2, #1
 775 0284 4B2AC3E5 		strb	r2, [r3, #2635]
 262:layer1/l23_api.c **** 		audio_set_enabled(est_req->tch_mode, est_req->audio_mode);
 776              		.loc 1 262 0
 777 0288 8600D5E5 		ldrb	r0, [r5, #134]	@ zero_extendqisi2
 778 028c 8710D5E5 		ldrb	r1, [r5, #135]	@ zero_extendqisi2
 779 0290 FEFFFFEB 		bl	audio_set_enabled
 780              	.L50:
 266:layer1/l23_api.c **** 	l1a_mftask_set(chan_nr2mf_task_mask(ul->chan_nr, NEIGH_MODE_PM));
 781              		.loc 1 266 0
 782 0294 0420D4E5 		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 783              	.LVL74:
 784              	.LBB284:
 785              	.LBB285:
  77:layer1/l23_api.c **** 	uint8_t cbits = chan_nr >> 3;
 786              		.loc 1 77 0
 787 0298 A231A0E1 		mov	r3, r2, lsr #3
 788              	.LVL75:
  84:layer1/l23_api.c **** 	if (cbits == 0x01) {
 789              		.loc 1 84 0
 790 029c 010053E3 		cmp	r3, #1
 791 02a0 0600001A 		bne	.L51
 792              	.LVL76:
  86:layer1/l23_api.c **** 		master_task = (tn & 1) ? MF_TASK_TCH_F_ODD : MF_TASK_TCH_F_EVEN;
 793              		.loc 1 86 0
 794 02a4 012002E2 		and	r2, r2, #1
 795              	.LVL77:
  87:layer1/l23_api.c **** 		multiframe = (tn & 1) ? MF26ODD : MF26EVEN;
 796              		.loc 1 87 0
 797 02a8 000052E3 		cmp	r2, #0
 798 02ac 0320A003 		moveq	r2, #3
 799 02b0 0220A013 		movne	r2, #2
 800 02b4 1010A003 		moveq	r1, #16
 801 02b8 1110A013 		movne	r1, #17
 802 02bc 150000EA 		b	.L52
 803              	.LVL78:
 804              	.L51:
  88:layer1/l23_api.c **** 	} else if ((cbits & 0x1e) == 0x02) {
 805              		.loc 1 88 0
 806 02c0 1E2003E2 		and	r2, r3, #30
 807              	.LVL79:
 808 02c4 020052E3 		cmp	r2, #2
 809 02c8 0500001A 		bne	.L53
  89:layer1/l23_api.c **** 		lch_idx = cbits & 0x1;
 810              		.loc 1 89 0
 811 02cc 013003E2 		and	r3, r3, #1
 812              	.LVL80:
  91:layer1/l23_api.c **** 		multiframe = (lch_idx & 1) ? MF26ODD : MF26EVEN;
 813              		.loc 1 91 0
 814 02d0 000053E3 		cmp	r3, #0
  90:layer1/l23_api.c **** 		master_task = MF_TASK_TCH_H_0 + lch_idx;
 815              		.loc 1 90 0
 816 02d4 121083E2 		add	r1, r3, #18
 817              	.LVL81:
  91:layer1/l23_api.c **** 		multiframe = (lch_idx & 1) ? MF26ODD : MF26EVEN;
 818              		.loc 1 91 0
 819 02d8 0320A003 		moveq	r2, #3
 820 02dc 0220A013 		movne	r2, #2
 821 02e0 0C0000EA 		b	.L52
 822              	.LVL82:
 823              	.L53:
  92:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
 824              		.loc 1 92 0
 825 02e4 1C2003E2 		and	r2, r3, #28
 826 02e8 040052E3 		cmp	r2, #4
  93:layer1/l23_api.c **** 		lch_idx = cbits & 0x3;
 827              		.loc 1 93 0
 828 02ec 03300302 		andeq	r3, r3, #3
 829              	.LVL83:
  94:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH4_0 + lch_idx;
 830              		.loc 1 94 0
 831 02f0 04108302 		addeq	r1, r3, #4
  92:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
 832              		.loc 1 92 0
 833 02f4 0600000A 		beq	.L86
  96:layer1/l23_api.c **** 	} else if ((cbits & 0x18) == 0x08) {
 834              		.loc 1 96 0
 835 02f8 182003E2 		and	r2, r3, #24
 836 02fc 080052E3 		cmp	r2, #8
  82:layer1/l23_api.c **** 	enum mf_type multiframe = 0;
 837              		.loc 1 82 0
 838 0300 0020A013 		movne	r2, #0
  80:layer1/l23_api.c **** 	enum mframe_task master_task = 0;
 839              		.loc 1 80 0
 840 0304 0210A011 		movne	r1, r2
  96:layer1/l23_api.c **** 	} else if ((cbits & 0x18) == 0x08) {
 841              		.loc 1 96 0
 842 0308 0200001A 		bne	.L52
  97:layer1/l23_api.c **** 		lch_idx = cbits & 0x7;
 843              		.loc 1 97 0
 844 030c 073003E2 		and	r3, r3, #7
  98:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH8_0 + lch_idx;
 845              		.loc 1 98 0
 846 0310 081083E2 		add	r1, r3, #8
 847              	.L86:
 848              	.LVL84:
  99:layer1/l23_api.c **** 		multiframe = MF51;
 849              		.loc 1 99 0
 850 0314 0120A0E3 		mov	r2, #1
 851              	.LVL85:
 852              	.L52:
  98:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH8_0 + lch_idx;
 853              		.loc 1 98 0
 854 0318 012042E2 		sub	r2, r2, #1
 855              	.LVL86:
 856 031c 020052E3 		cmp	r2, #2
 857 0320 D0359F95 		ldrls	r3, .L93+32
 858 0324 02319397 		ldrls	r3, [r3, r2, asl #2]
 859              	.LBE285:
 860 0328 0030A083 		movhi	r3, #0
 861              	.LVL87:
 862              	.LBE284:
 266:layer1/l23_api.c **** 	l1a_mftask_set(chan_nr2mf_task_mask(ul->chan_nr, NEIGH_MODE_PM));
 863              		.loc 1 266 0
 864 032c 0100A0E3 		mov	r0, #1
 865 0330 100183E1 		orr	r0, r3, r0, asl r1
 866 0334 FEFFFFEB 		bl	l1a_mftask_set
 867              	.LVL88:
 868              	.LBE272:
 869              	.LBE271:
 631:layer1/l23_api.c **** 	case L1CTL_FBSB_REQ:
 632:layer1/l23_api.c **** 		l1ctl_rx_fbsb_req(msg);
 633:layer1/l23_api.c **** 		break;
 634:layer1/l23_api.c **** 	case L1CTL_DM_EST_REQ:
 635:layer1/l23_api.c **** 		l1ctl_rx_dm_est_req(msg);
 636:layer1/l23_api.c **** 		break;
 870              		.loc 1 636 0
 871 0338 600100EA 		b	.L26
 872              	.LVL89:
 873              	.L34:
 874              	.LBB286:
 875              	.LBB287:
 323:layer1/l23_api.c **** 	l1s.dedicated.type = GSM_DCHAN_NONE;
 876              		.loc 1 323 0
 877 033c A4559FE5 		ldr	r5, .L93+16
 321:layer1/l23_api.c **** 	printd("L1CTL_DM_REL_REQ\n");
 878              		.loc 1 321 0
 879 0340 B4059FE5 		ldr	r0, .L93+36
 323:layer1/l23_api.c **** 	l1s.dedicated.type = GSM_DCHAN_NONE;
 880              		.loc 1 323 0
 881 0344 0040A0E3 		mov	r4, #0
 882              	.LVL90:
 321:layer1/l23_api.c **** 	printd("L1CTL_DM_REL_REQ\n");
 883              		.loc 1 321 0
 884 0348 FEFFFFEB 		bl	puts
 885              	.LVL91:
 322:layer1/l23_api.c **** 	l1a_mftask_set(0);
 886              		.loc 1 322 0
 887 034c 0000A0E3 		mov	r0, #0
 888 0350 FEFFFFEB 		bl	l1a_mftask_set
 324:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_MAIN]);
 889              		.loc 1 324 0
 890 0354 A50E85E2 		add	r0, r5, #2640
 323:layer1/l23_api.c **** 	l1s.dedicated.type = GSM_DCHAN_NONE;
 891              		.loc 1 323 0
 892 0358 084B85E5 		str	r4, [r5, #2824]
 324:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_MAIN]);
 893              		.loc 1 324 0
 894 035c FEFFFFEB 		bl	l1a_txq_msgb_flush
 325:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_SACCH]);
 895              		.loc 1 325 0
 896 0360 98059FE5 		ldr	r0, .L93+40
 897 0364 FEFFFFEB 		bl	l1a_txq_msgb_flush
 326:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 898              		.loc 1 326 0
 899 0368 A60E85E2 		add	r0, r5, #2656
 900 036c FEFFFFEB 		bl	l1a_txq_msgb_flush
 327:layer1/l23_api.c **** 	l1a_meas_msgb_set(NULL);
 901              		.loc 1 327 0
 902 0370 0400A0E1 		mov	r0, r4
 903 0374 FEFFFFEB 		bl	l1a_meas_msgb_set
 328:layer1/l23_api.c **** 	dsp_load_ciph_param(0, NULL);
 904              		.loc 1 328 0
 905 0378 0410A0E1 		mov	r1, r4
 906 037c 0400A0E1 		mov	r0, r4
 907 0380 FEFFFFEB 		bl	dsp_load_ciph_param
 329:layer1/l23_api.c **** 	l1a_tch_mode_set(GSM48_CMODE_SIGN);
 908              		.loc 1 329 0
 909 0384 0400A0E1 		mov	r0, r4
 910 0388 FEFFFFEB 		bl	l1a_tch_mode_set
 330:layer1/l23_api.c **** 	audio_set_enabled(GSM48_CMODE_SIGN, 0);
 911              		.loc 1 330 0
 912 038c 0400A0E1 		mov	r0, r4
 913 0390 0410A0E1 		mov	r1, r4
 914 0394 FEFFFFEB 		bl	audio_set_enabled
 331:layer1/l23_api.c **** 	l1s.neigh_pm.n = 0;
 915              		.loc 1 331 0
 916 0398 1C4CC5E5 		strb	r4, [r5, #3100]
 917              	.LBE287:
 918              	.LBE286:
 637:layer1/l23_api.c **** 	case L1CTL_DM_REL_REQ:
 638:layer1/l23_api.c **** 		l1ctl_rx_dm_rel_req(msg);
 639:layer1/l23_api.c **** 		break;
 919              		.loc 1 639 0
 920 039c 470100EA 		b	.L26
 921              	.LVL92:
 922              	.L35:
 923              	.LBB288:
 924              	.LBB289:
 338:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 925              		.loc 1 338 0
 926 03a0 044084E2 		add	r4, r4, #4
 927              	.LVL93:
 339:layer1/l23_api.c **** 	struct l1ctl_par_req *par_req = (struct l1ctl_par_req *) ul->payload;
 928              		.loc 1 339 0
 929 03a4 045084E2 		add	r5, r4, #4
 930              	.LVL94:
 341:layer1/l23_api.c **** 	printd("L1CTL_PARAM_REQ (ta=%d, tx_power=%d)\n", par_req->ta,
 931              		.loc 1 341 0
 932 03a8 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 933 03ac 50059FE5 		ldr	r0, .L93+44
 934 03b0 D410D4E1 		ldrsb	r1, [r4, #4]
 935 03b4 FEFFFFEB 		bl	printf
 936              	.LVL95:
 344:layer1/l23_api.c **** 	l1s.ta = par_req->ta;
 937              		.loc 1 344 0
 938 03b8 0420D4E5 		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 939 03bc 24359FE5 		ldr	r3, .L93+16
 940 03c0 482AC3E5 		strb	r2, [r3, #2632]
 345:layer1/l23_api.c **** 	l1s.tx_power = par_req->tx_power;
 941              		.loc 1 345 0
 942 03c4 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 943 03c8 492AC3E5 		strb	r2, [r3, #2633]
 944              	.LBE289:
 945              	.LBE288:
 640:layer1/l23_api.c **** 	case L1CTL_PARAM_REQ:
 641:layer1/l23_api.c **** 		l1ctl_rx_param_req(msg);
 642:layer1/l23_api.c **** 		break;
 946              		.loc 1 642 0
 947 03cc 3B0100EA 		b	.L26
 948              	.LVL96:
 949              	.L36:
 950              	.LBB290:
 951              	.LBB291:
 273:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 952              		.loc 1 273 0
 953 03d0 044084E2 		add	r4, r4, #4
 954              	.LVL97:
 275:layer1/l23_api.c **** 			(struct l1ctl_dm_freq_req *) ul->payload;
 955              		.loc 1 275 0
 956 03d4 045084E2 		add	r5, r4, #4
 957              	.LVL98:
 277:layer1/l23_api.c **** 	printd("L1CTL_DM_FREQ_REQ (arfcn=%u, tsc=%u)\n",
 958              		.loc 1 277 0
 959 03d8 0430D5E5 		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 960 03dc 0510D5E5 		ldrb	r1, [r5, #5]	@ zero_extendqisi2
 961 03e0 011483E1 		orr	r1, r3, r1, asl #8
 962              	.LVL99:
 963              	.LBB292:
 964              	.LBB293:
 965              		.loc 4 51 0
 966 03e4 2134A0E1 		mov	r3, r1, lsr #8
 967 03e8 011483E1 		orr	r1, r3, r1, asl #8
 968              	.LVL100:
 969              	.LBE293:
 970              	.LBE292:
 277:layer1/l23_api.c **** 	printd("L1CTL_DM_FREQ_REQ (arfcn=%u, tsc=%u)\n",
 971              		.loc 1 277 0
 972 03ec 0118A0E1 		mov	r1, r1, asl #16
 973 03f0 0220D5E5 		ldrb	r2, [r5, #2]	@ zero_extendqisi2
 974 03f4 0C059FE5 		ldr	r0, .L93+48
 975 03f8 2118A0E1 		mov	r1, r1, lsr #16
 976 03fc FEFFFFEB 		bl	printf
 977              	.LVL101:
 281:layer1/l23_api.c **** 	l1s.dedicated.st_tsc  = freq_req->tsc;
 978              		.loc 1 281 0
 979 0400 0220D5E5 		ldrb	r2, [r5, #2]	@ zero_extendqisi2
 980 0404 DC349FE5 		ldr	r3, .L93+16
 981 0408 942BC3E5 		strb	r2, [r3, #2964]
 282:layer1/l23_api.c **** 	l1s.dedicated.st_h    = freq_req->h;
 982              		.loc 1 282 0
 983 040c 0320D5E5 		ldrb	r2, [r5, #3]	@ zero_extendqisi2
 984 0410 962BC3E5 		strb	r2, [r3, #2966]
 284:layer1/l23_api.c **** 	if (freq_req->h) {
 985              		.loc 1 284 0
 986 0414 0320D5E5 		ldrb	r2, [r5, #3]	@ zero_extendqisi2
 987 0418 000052E3 		cmp	r2, #0
 988 041c 1500000A 		beq	.L56
 989              	.LBB294:
 286:layer1/l23_api.c **** 		l1s.dedicated.st_h1.hsn  = freq_req->h1.hsn;
 990              		.loc 1 286 0
 991 0420 0420D5E5 		ldrb	r2, [r5, #4]	@ zero_extendqisi2
 992 0424 982BC3E5 		strb	r2, [r3, #2968]
 287:layer1/l23_api.c **** 		l1s.dedicated.st_h1.maio = freq_req->h1.maio;
 993              		.loc 1 287 0
 994 0428 0520D5E5 		ldrb	r2, [r5, #5]	@ zero_extendqisi2
 995 042c 992BC3E5 		strb	r2, [r3, #2969]
 288:layer1/l23_api.c **** 		l1s.dedicated.st_h1.n    = freq_req->h1.n;
 996              		.loc 1 288 0
 997 0430 0620D5E5 		ldrb	r2, [r5, #6]	@ zero_extendqisi2
 998 0434 9A2BC3E5 		strb	r2, [r3, #2970]
 999              	.LVL102:
 1000 0438 CC249FE5 		ldr	r2, .L93+52
 289:layer1/l23_api.c **** 		for (i=0; i<freq_req->h1.n; i++)
 1001              		.loc 1 289 0
 1002 043c 0030A0E3 		mov	r3, #0
 1003 0440 080000EA 		b	.L57
 1004              	.LVL103:
 1005              	.L58:
 290:layer1/l23_api.c **** 			l1s.dedicated.st_h1.ma[i] = ntohs(freq_req->h1.ma[i]);
 1006              		.loc 1 290 0
 1007 0444 040083E2 		add	r0, r3, #4
 1008 0448 8010D5E7 		ldrb	r1, [r5, r0, asl #1]	@ zero_extendqisi2
 1009 044c 800085E0 		add	r0, r5, r0, asl #1
 1010 0450 0100D0E5 		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 1011 0454 001481E1 		orr	r1, r1, r0, asl #8
 1012              	.LVL104:
 1013              	.LBB295:
 1014              	.LBB296:
 1015              		.loc 4 51 0
 1016 0458 2104A0E1 		mov	r0, r1, lsr #8
 1017 045c 011480E1 		orr	r1, r0, r1, asl #8
 1018              	.LVL105:
 1019              	.LBE296:
 1020              	.LBE295:
 290:layer1/l23_api.c **** 			l1s.dedicated.st_h1.ma[i] = ntohs(freq_req->h1.ma[i]);
 1021              		.loc 1 290 0
 1022 0460 B210E2E1 		strh	r1, [r2, #2]!	@ movhi
 289:layer1/l23_api.c **** 		for (i=0; i<freq_req->h1.n; i++)
 1023              		.loc 1 289 0
 1024 0464 013083E2 		add	r3, r3, #1
 1025              	.LVL106:
 1026              	.L57:
 1027 0468 0610D5E5 		ldrb	r1, [r5, #6]	@ zero_extendqisi2
 1028 046c 010053E1 		cmp	r3, r1
 1029 0470 F3FFFFBA 		blt	.L58
 1030 0474 060000EA 		b	.L59
 1031              	.LVL107:
 1032              	.L56:
 1033              	.LBE294:
 292:layer1/l23_api.c **** 		l1s.dedicated.st_h0.arfcn = ntohs(freq_req->h0.band_arfcn);
 1034              		.loc 1 292 0
 1035 0478 0510D5E5 		ldrb	r1, [r5, #5]	@ zero_extendqisi2
 1036 047c 0420D5E5 		ldrb	r2, [r5, #4]	@ zero_extendqisi2
 1037 0480 012482E1 		orr	r2, r2, r1, asl #8
 1038              	.LVL108:
 1039              	.LBB297:
 1040              	.LBB298:
 1041              		.loc 4 51 0
 1042 0484 2214A0E1 		mov	r1, r2, lsr #8
 1043 0488 022481E1 		orr	r2, r1, r2, asl #8
 1044              	.LVL109:
 1045              	.LBE298:
 1046              	.LBE297:
 292:layer1/l23_api.c **** 		l1s.dedicated.st_h0.arfcn = ntohs(freq_req->h0.band_arfcn);
 1047              		.loc 1 292 0
 1048 048c 7C149FE5 		ldr	r1, .L93+56
 1049 0490 B12083E1 		strh	r2, [r3, r1]	@ movhi
 1050              	.L59:
 295:layer1/l23_api.c **** 	l1a_freq_req(ntohs(freq_req->fn));
 1051              		.loc 1 295 0
 1052 0494 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1053 0498 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 1054 049c 023483E1 		orr	r3, r3, r2, asl #8
 1055              	.LVL110:
 1056              	.LBB299:
 1057              	.LBB300:
 1058              		.loc 4 51 0
 1059 04a0 2304A0E1 		mov	r0, r3, lsr #8
 1060 04a4 033480E1 		orr	r3, r0, r3, asl #8
 1061              	.LVL111:
 1062              	.LBE300:
 1063              	.LBE299:
 295:layer1/l23_api.c **** 	l1a_freq_req(ntohs(freq_req->fn));
 1064              		.loc 1 295 0
 1065 04a8 0308A0E1 		mov	r0, r3, asl #16
 1066 04ac 2008A0E1 		mov	r0, r0, lsr #16
 1067 04b0 FEFFFFEB 		bl	l1a_freq_req
 1068              	.LBE291:
 1069              	.LBE290:
 643:layer1/l23_api.c **** 	case L1CTL_DM_FREQ_REQ:
 644:layer1/l23_api.c **** 		l1ctl_rx_dm_freq_req(msg);
 645:layer1/l23_api.c **** 		break;
 1070              		.loc 1 645 0
 1071 04b4 010100EA 		b	.L26
 1072              	.LVL112:
 1073              	.L37:
 1074              	.LBB301:
 1075              	.LBB302:
 304:layer1/l23_api.c **** 	uint8_t key_len = msg->len - sizeof(*l1h) - sizeof(*ul) - sizeof(*cr);
 1076              		.loc 1 304 0
 1077 04b8 095041E2 		sub	r5, r1, #9
 302:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 1078              		.loc 1 302 0
 1079 04bc 047084E2 		add	r7, r4, #4
 304:layer1/l23_api.c **** 	uint8_t key_len = msg->len - sizeof(*l1h) - sizeof(*ul) - sizeof(*cr);
 1080              		.loc 1 304 0
 1081 04c0 FF5005E2 		and	r5, r5, #255
 1082              	.LVL113:
 306:layer1/l23_api.c **** 	printd("L1CTL_CRYPTO_REQ (algo=A5/%u, len=%u)\n", cr->algo, key_len);
 1083              		.loc 1 306 0
 1084 04c4 48049FE5 		ldr	r0, .L93+60
 1085 04c8 0410D7E5 		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1086 04cc 0520A0E1 		mov	r2, r5
 1087 04d0 FEFFFFEB 		bl	printf
 308:layer1/l23_api.c **** 	if (cr->algo && key_len != 8) {
 1088              		.loc 1 308 0
 1089 04d4 0400D7E5 		ldrb	r0, [r7, #4]	@ zero_extendqisi2
 1090 04d8 080055E3 		cmp	r5, #8
 1091 04dc 00005013 		cmpne	r0, #0
 309:layer1/l23_api.c **** 		printd("L1CTL_CRYPTO_REQ -> Invalid key\n");
 1092              		.loc 1 309 0
 1093 04e0 30049F15 		ldrne	r0, .L93+64
 308:layer1/l23_api.c **** 	if (cr->algo && key_len != 8) {
 1094              		.loc 1 308 0
 1095 04e4 7D00001A 		bne	.L90
 313:layer1/l23_api.c **** 	dsp_load_ciph_param(cr->algo, cr->key);
 1096              		.loc 1 313 0
 1097 04e8 091084E2 		add	r1, r4, #9
 1098 04ec FEFFFFEB 		bl	dsp_load_ciph_param
 1099 04f0 F20000EA 		b	.L26
 1100              	.LVL114:
 1101              	.L28:
 1102              	.LBE302:
 1103              	.LBE301:
 1104              	.LBB303:
 1105              	.LBB304:
 352:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 1106              		.loc 1 352 0
 1107 04f4 044084E2 		add	r4, r4, #4
 1108              	.LVL115:
 353:layer1/l23_api.c **** 	struct l1ctl_rach_req *rach_req = (struct l1ctl_rach_req *) ul->payload;
 1109              		.loc 1 353 0
 1110 04f8 045084E2 		add	r5, r4, #4
 1111              	.LVL116:
 355:layer1/l23_api.c **** 	printd("L1CTL_RACH_REQ (ra=0x%02x, offset=%d combined=%d)\n",
 1112              		.loc 1 355 0
 1113 04fc 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 1114 0500 0320D5E5 		ldrb	r2, [r5, #3]	@ zero_extendqisi2
 1115 0504 022483E1 		orr	r2, r3, r2, asl #8
 1116              	.LVL117:
 1117              	.LBB305:
 1118              	.LBB306:
 1119              		.loc 4 51 0
 1120 0508 2234A0E1 		mov	r3, r2, lsr #8
 1121 050c 022483E1 		orr	r2, r3, r2, asl #8
 1122              	.LVL118:
 1123              	.LBE306:
 1124              	.LBE305:
 355:layer1/l23_api.c **** 	printd("L1CTL_RACH_REQ (ra=0x%02x, offset=%d combined=%d)\n",
 1125              		.loc 1 355 0
 1126 0510 0228A0E1 		mov	r2, r2, asl #16
 1127 0514 0410D4E5 		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 1128 0518 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 1129 051c 2228A0E1 		mov	r2, r2, lsr #16
 1130 0520 F4039FE5 		ldr	r0, .L93+68
 1131 0524 FEFFFFEB 		bl	printf
 1132              	.LVL119:
 358:layer1/l23_api.c **** 	l1a_rach_req(ntohs(rach_req->offset), rach_req->combined,
 1133              		.loc 1 358 0
 1134 0528 0320D5E5 		ldrb	r2, [r5, #3]	@ zero_extendqisi2
 1135 052c 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 1136 0530 023483E1 		orr	r3, r3, r2, asl #8
 1137              	.LVL120:
 1138              	.LBB307:
 1139              	.LBB308:
 1140              		.loc 4 51 0
 1141 0534 2304A0E1 		mov	r0, r3, lsr #8
 1142 0538 033480E1 		orr	r3, r0, r3, asl #8
 1143              	.LVL121:
 1144              	.LBE308:
 1145              	.LBE307:
 358:layer1/l23_api.c **** 	l1a_rach_req(ntohs(rach_req->offset), rach_req->combined,
 1146              		.loc 1 358 0
 1147 053c 0308A0E1 		mov	r0, r3, asl #16
 1148 0540 2008A0E1 		mov	r0, r0, lsr #16
 1149 0544 0110D5E5 		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 1150 0548 0420D4E5 		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 1151 054c FEFFFFEB 		bl	l1a_rach_req
 1152              	.LBE304:
 1153              	.LBE303:
 646:layer1/l23_api.c **** 	case L1CTL_CRYPTO_REQ:
 647:layer1/l23_api.c **** 		l1ctl_rx_crypto_req(msg);
 648:layer1/l23_api.c **** 		break;
 649:layer1/l23_api.c **** 	case L1CTL_RACH_REQ:
 650:layer1/l23_api.c **** 		l1ctl_rx_rach_req(msg);
 651:layer1/l23_api.c **** 		break;
 1154              		.loc 1 651 0
 1155 0550 DA0000EA 		b	.L26
 1156              	.LVL122:
 1157              	.L30:
 1158              	.LBB309:
 1159              	.LBB311:
 366:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 1160              		.loc 1 366 0
 1161 0554 047084E2 		add	r7, r4, #4
 1162              	.LVL123:
 367:layer1/l23_api.c **** 	struct l1ctl_data_ind *data_ind = (struct l1ctl_data_ind *) ul->payload;
 1163              		.loc 1 367 0
 1164 0558 045087E2 		add	r5, r7, #4
 1165              	.LVL124:
 370:layer1/l23_api.c **** 	printd("L1CTL_DATA_REQ (link_id=0x%02x)\n", ul->link_id);
 1166              		.loc 1 370 0
 1167 055c BC039FE5 		ldr	r0, .L93+72
 1168 0560 0110D7E5 		ldrb	r1, [r7, #1]	@ zero_extendqisi2
 1169 0564 FEFFFFEB 		bl	printf
 372:layer1/l23_api.c **** 	msg->l3h = data_ind->data;
 1170              		.loc 1 372 0
 1171 0568 185086E5 		str	r5, [r6, #24]
 373:layer1/l23_api.c **** 	if (ul->link_id & 0x40) {
 1172              		.loc 1 373 0
 1173 056c 0130D7E5 		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 1174 0570 400013E3 		tst	r3, #64
 1175 0574 0C00000A 		beq	.L82
 1176              	.LBB314:
 375:layer1/l23_api.c **** 		if (gh->proto_discr == GSM48_PDISC_RR
 1177              		.loc 1 375 0
 1178 0578 0D20D4E5 		ldrb	r2, [r4, #13]	@ zero_extendqisi2
 1179 057c 060052E3 		cmp	r2, #6
 374:layer1/l23_api.c **** 		struct gsm48_hdr *gh = (struct gsm48_hdr *)(data_ind->data + 5);
 1180              		.loc 1 374 0
 1181 0580 0D3084E2 		add	r3, r4, #13
 1182              	.LVL125:
 375:layer1/l23_api.c **** 		if (gh->proto_discr == GSM48_PDISC_RR
 1183              		.loc 1 375 0
 1184 0584 0A00001A 		bne	.L84
 376:layer1/l23_api.c **** 		 && gh->msg_type == GSM48_MT_RR_MEAS_REP) {
 1185              		.loc 1 376 0
 1186 0588 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1187 058c 150053E3 		cmp	r3, #21
 1188 0590 0700001A 		bne	.L84
 377:layer1/l23_api.c **** 			printd("updating measurement report\n");
 1189              		.loc 1 377 0
 1190 0594 88039FE5 		ldr	r0, .L93+76
 1191 0598 FEFFFFEB 		bl	puts
 378:layer1/l23_api.c **** 			l1a_meas_msgb_set(msg);
 1192              		.loc 1 378 0
 1193 059c 0600A0E1 		mov	r0, r6
 1194              	.LBE314:
 1195              	.LBE311:
 1196              	.LBE309:
 652:layer1/l23_api.c **** 	case L1CTL_DATA_REQ:
 653:layer1/l23_api.c **** 		l1ctl_rx_data_req(msg);
 654:layer1/l23_api.c **** 		/* we have to keep the msgb, not free it! */
 655:layer1/l23_api.c **** 		goto exit_nofree;
 656:layer1/l23_api.c **** 	case L1CTL_PM_REQ:
 657:layer1/l23_api.c **** 		l1ctl_rx_pm_req(msg);
 658:layer1/l23_api.c **** 		break;
 659:layer1/l23_api.c **** 	case L1CTL_RESET_REQ:
 660:layer1/l23_api.c **** 		l1ctl_rx_reset_req(msg);
 661:layer1/l23_api.c **** 		break;
 662:layer1/l23_api.c **** 	case L1CTL_CCCH_MODE_REQ:
 663:layer1/l23_api.c **** 		l1ctl_rx_ccch_mode_req(msg);
 664:layer1/l23_api.c **** 		break;
 665:layer1/l23_api.c **** 	case L1CTL_TCH_MODE_REQ:
 666:layer1/l23_api.c **** 		l1ctl_rx_tch_mode_req(msg);
 667:layer1/l23_api.c **** 		break;
 668:layer1/l23_api.c **** 	case L1CTL_NEIGH_PM_REQ:
 669:layer1/l23_api.c **** 		l1ctl_rx_neigh_pm_req(msg);
 670:layer1/l23_api.c **** 		break;
 671:layer1/l23_api.c **** 	case L1CTL_TRAFFIC_REQ:
 672:layer1/l23_api.c **** 		l1ctl_rx_traffic_req(msg);
 673:layer1/l23_api.c **** 		/* we have to keep the msgb, not free it! */
 674:layer1/l23_api.c **** 		goto exit_nofree;
 675:layer1/l23_api.c **** 	case L1CTL_SIM_REQ:
 676:layer1/l23_api.c **** 		l1ctl_sim_req(msg);
 677:layer1/l23_api.c **** 		break;
 678:layer1/l23_api.c **** 	}
 679:layer1/l23_api.c **** 
 680:layer1/l23_api.c **** exit_msgbfree:
 681:layer1/l23_api.c **** 	msgb_free(msg);
 682:layer1/l23_api.c **** exit_nofree:
 683:layer1/l23_api.c **** 	return;
 684:layer1/l23_api.c **** }
 1197              		.loc 1 684 0
 1198 05a0 08D08DE2 		add	sp, sp, #8
 1199 05a4 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 1200              	.LBB317:
 1201              	.LBB310:
 1202              	.LBB313:
 378:layer1/l23_api.c **** 			l1a_meas_msgb_set(msg);
 1203              		.loc 1 378 0
 1204 05a8 FEFFFFEA 		b	l1a_meas_msgb_set
 1205              	.LVL126:
 1206              	.L82:
 1207              	.LBE313:
 383:layer1/l23_api.c **** 		tx_queue = &l1s.tx_queue[L1S_CHAN_MAIN];
 1208              		.loc 1 383 0
 1209 05ac 74439FE5 		ldr	r4, .L93+80
 1210              	.LVL127:
 1211 05b0 000000EA 		b	.L61
 1212              	.LVL128:
 1213              	.L84:
 1214              	.LBB312:
 381:layer1/l23_api.c **** 		tx_queue = &l1s.tx_queue[L1S_CHAN_SACCH];
 1215              		.loc 1 381 0
 1216 05b4 44439FE5 		ldr	r4, .L93+40
 1217              	.LVL129:
 1218              	.L61:
 1219              	.LBE312:
 385:layer1/l23_api.c **** 	printd("ul=%p, ul->payload=%p, data_ind=%p, data_ind->data=%p l3h=%p\n",
 1220              		.loc 1 385 0
 1221 05b8 6C039FE5 		ldr	r0, .L93+84
 1222 05bc 0710A0E1 		mov	r1, r7
 1223 05c0 042087E2 		add	r2, r7, #4
 1224 05c4 0530A0E1 		mov	r3, r5
 1225 05c8 00508DE5 		str	r5, [sp, #0]
 1226 05cc 04508DE5 		str	r5, [sp, #4]
 1227 05d0 FEFFFFEB 		bl	printf
 388:layer1/l23_api.c **** 	l1a_txq_msgb_enq(tx_queue, msg);
 1228              		.loc 1 388 0
 1229 05d4 0400A0E1 		mov	r0, r4
 1230 05d8 9F0000EA 		b	.L91
 1231              	.LVL130:
 1232              	.L31:
 1233              	.LBE310:
 1234              	.LBE317:
 1235              	.LBB318:
 1236              	.LBB319:
 397:layer1/l23_api.c **** 	switch (pm_req->type) {
 1237              		.loc 1 397 0
 1238 05dc 0420D4E5 		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 1239 05e0 010052E3 		cmp	r2, #1
 395:layer1/l23_api.c **** 	struct l1ctl_pm_req *pm_req = (struct l1ctl_pm_req *) l1h->data;
 1240              		.loc 1 395 0
 1241 05e4 043084E2 		add	r3, r4, #4
 1242              	.LVL131:
 397:layer1/l23_api.c **** 	switch (pm_req->type) {
 1243              		.loc 1 397 0
 1244 05e8 1C00001A 		bne	.L62
 399:layer1/l23_api.c **** 		l1s.pm.mode = 1;
 1245              		.loc 1 399 0
 1246 05ec F4029FE5 		ldr	r0, .L93+16
 1247 05f0 F42A80E5 		str	r2, [r0, #2804]
 401:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_from);
 1248              		.loc 1 401 0
 1249 05f4 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 1250 05f8 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1251 05fc 012482E1 		orr	r2, r2, r1, asl #8
 1252              	.LVL132:
 1253              	.LBB320:
 1254              	.LBB321:
 1255              		.loc 4 51 0
 1256 0600 2214A0E1 		mov	r1, r2, lsr #8
 1257 0604 021481E1 		orr	r1, r1, r2, asl #8
 1258 0608 0118A0E1 		mov	r1, r1, asl #16
 1259              	.LBE321:
 1260              	.LBE320:
 400:layer1/l23_api.c **** 		l1s.pm.range.arfcn_start =
 1261              		.loc 1 400 0
 1262 060c 1C239FE5 		ldr	r2, .L93+88
 1263              	.LVL133:
 1264              	.LBB323:
 1265              	.LBB322:
 1266              		.loc 4 51 0
 1267 0610 2118A0E1 		mov	r1, r1, lsr #16
 1268              	.LBE322:
 1269              	.LBE323:
 400:layer1/l23_api.c **** 		l1s.pm.range.arfcn_start =
 1270              		.loc 1 400 0
 1271 0614 B21080E1 		strh	r1, [r0, r2]	@ movhi
 403:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_from);
 1272              		.loc 1 403 0
 1273 0618 05C0D3E5 		ldrb	ip, [r3, #5]	@ zero_extendqisi2
 1274 061c 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1275 0620 0C2482E1 		orr	r2, r2, ip, asl #8
 1276              	.LVL134:
 1277              	.LBB324:
 1278              	.LBB325:
 1279              		.loc 4 51 0
 1280 0624 22C4A0E1 		mov	ip, r2, lsr #8
 1281 0628 02248CE1 		orr	r2, ip, r2, asl #8
 1282              	.LVL135:
 1283              	.LBE325:
 1284              	.LBE324:
 402:layer1/l23_api.c **** 		l1s.pm.range.arfcn_next =
 1285              		.loc 1 402 0
 1286 062c 00C39FE5 		ldr	ip, .L93+92
 1287 0630 BC2080E1 		strh	r2, [r0, ip]	@ movhi
 405:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_to);
 1288              		.loc 1 405 0
 1289 0634 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 1290 0638 0730D3E5 		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 1291 063c 033482E1 		orr	r3, r2, r3, asl #8
 1292              	.LVL136:
 1293              	.LBB326:
 1294              	.LBB327:
 1295              		.loc 4 51 0
 1296 0640 2324A0E1 		mov	r2, r3, lsr #8
 1297 0644 032482E1 		orr	r2, r2, r3, asl #8
 1298 0648 0228A0E1 		mov	r2, r2, asl #16
 1299              	.LBE327:
 1300              	.LBE326:
 404:layer1/l23_api.c **** 		l1s.pm.range.arfcn_end =
 1301              		.loc 1 404 0
 1302 064c E4329FE5 		ldr	r3, .L93+96
 1303              	.LVL137:
 1304              	.LBB329:
 1305              	.LBB328:
 1306              		.loc 4 51 0
 1307 0650 2228A0E1 		mov	r2, r2, lsr #16
 1308              	.LBE328:
 1309              	.LBE329:
 404:layer1/l23_api.c **** 		l1s.pm.range.arfcn_end =
 1310              		.loc 1 404 0
 1311 0654 B32080E1 		strh	r2, [r0, r3]	@ movhi
 406:layer1/l23_api.c **** 		printf("L1CTL_PM_REQ start=%u end=%u\n",
 1312              		.loc 1 406 0
 1313 0658 DC029FE5 		ldr	r0, .L93+100
 1314 065c FEFFFFEB 		bl	printf
 1315              	.L62:
 410:layer1/l23_api.c **** 	l1s_reset_hw(); /* must reset, otherwise measurement results are delayed */
 1316              		.loc 1 410 0
 1317 0660 FEFFFFEB 		bl	l1s_reset_hw
 411:layer1/l23_api.c **** 	l1s_pm_test(1, l1s.pm.range.arfcn_next);
 1318              		.loc 1 411 0
 1319 0664 C8329FE5 		ldr	r3, .L93+92
 1320 0668 78229FE5 		ldr	r2, .L93+16
 1321 066c 0100A0E3 		mov	r0, #1
 1322 0670 B31092E1 		ldrh	r1, [r2, r3]
 1323 0674 FEFFFFEB 		bl	l1s_pm_test
 1324              	.LBE319:
 1325              	.LBE318:
 658:layer1/l23_api.c **** 		break;
 1326              		.loc 1 658 0
 1327 0678 900000EA 		b	.L26
 1328              	.LVL138:
 1329              	.L32:
 1330              	.LBB330:
 1331              	.LBB331:
 433:layer1/l23_api.c **** 	switch (reset_req->type) {
 1332              		.loc 1 433 0
 1333 067c 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1334 0680 010053E3 		cmp	r3, #1
 1335 0684 0300000A 		beq	.L65
 1336 0688 020053E3 		cmp	r3, #2
 447:layer1/l23_api.c **** 		printf("unknown L1CTL_RESET_REQ type\n");
 1337              		.loc 1 447 0
 1338 068c AC029F15 		ldrne	r0, .L93+104
 433:layer1/l23_api.c **** 	switch (reset_req->type) {
 1339              		.loc 1 433 0
 1340 0690 1200001A 		bne	.L90
 1341 0694 0A0000EA 		b	.L92
 1342              	.L65:
 435:layer1/l23_api.c **** 		printf("L1CTL_RESET_REQ: FULL!\n");
 1343              		.loc 1 435 0
 1344 0698 A4029FE5 		ldr	r0, .L93+108
 1345 069c FEFFFFEB 		bl	puts
 436:layer1/l23_api.c **** 		l1s_reset();
 1346              		.loc 1 436 0
 1347 06a0 FEFFFFEB 		bl	l1s_reset
 437:layer1/l23_api.c **** 		l1s_reset_hw();
 1348              		.loc 1 437 0
 1349 06a4 FEFFFFEB 		bl	l1s_reset_hw
 438:layer1/l23_api.c **** 		audio_set_enabled(GSM48_CMODE_SIGN, 0);
 1350              		.loc 1 438 0
 1351 06a8 0000A0E3 		mov	r0, #0
 1352 06ac 0010A0E1 		mov	r1, r0
 1353 06b0 FEFFFFEB 		bl	audio_set_enabled
 439:layer1/l23_api.c **** 		l1ctl_tx_reset(L1CTL_RESET_CONF, reset_req->type);
 1354              		.loc 1 439 0
 1355 06b4 0E00A0E3 		mov	r0, #14
 1356 06b8 0410D4E5 		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 1357 06bc FEFFFFEB 		bl	l1ctl_tx_reset
 1358 06c0 7E0000EA 		b	.L26
 1359              	.L92:
 442:layer1/l23_api.c **** 		printf("L1CTL_RESET_REQ: SCHED!\n");
 1360              		.loc 1 442 0
 1361 06c4 7C029FE5 		ldr	r0, .L93+112
 1362 06c8 FEFFFFEB 		bl	puts
 443:layer1/l23_api.c **** 		l1ctl_tx_reset(L1CTL_RESET_CONF, reset_req->type);
 1363              		.loc 1 443 0
 1364 06cc 0E00A0E3 		mov	r0, #14
 1365 06d0 0410D4E5 		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 1366 06d4 FEFFFFEB 		bl	l1ctl_tx_reset
 444:layer1/l23_api.c **** 		sched_gsmtime_reset();
 1367              		.loc 1 444 0
 1368 06d8 FEFFFFEB 		bl	sched_gsmtime_reset
 1369 06dc 770000EA 		b	.L26
 1370              	.LVL139:
 1371              	.L90:
 447:layer1/l23_api.c **** 		printf("unknown L1CTL_RESET_REQ type\n");
 1372              		.loc 1 447 0
 1373 06e0 FEFFFFEB 		bl	puts
 1374 06e4 750000EA 		b	.L26
 1375              	.LVL140:
 1376              	.L33:
 1377              	.LBE331:
 1378              	.LBE330:
 1379              	.LBB332:
 1380              	.LBB333:
 470:layer1/l23_api.c **** 	uint8_t ccch_mode = ccch_mode_req->ccch_mode;
 1381              		.loc 1 470 0
 1382 06e8 0440D4E5 		ldrb	r4, [r4, #4]	@ zero_extendqisi2
 1383              	.LVL141:
 473:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = ccch_mode;
 1384              		.loc 1 473 0
 1385 06ec F4319FE5 		ldr	r3, .L93+16
 476:layer1/l23_api.c **** 	mframe_disable(MF_TASK_CCCH_COMB);
 1386              		.loc 1 476 0
 1387 06f0 0300A0E3 		mov	r0, #3
 473:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = ccch_mode;
 1388              		.loc 1 473 0
 1389 06f4 1B40C3E5 		strb	r4, [r3, #27]
 476:layer1/l23_api.c **** 	mframe_disable(MF_TASK_CCCH_COMB);
 1390              		.loc 1 476 0
 1391 06f8 FEFFFFEB 		bl	mframe_disable
 1392              	.LVL142:
 477:layer1/l23_api.c **** 	mframe_disable(MF_TASK_CCCH);
 1393              		.loc 1 477 0
 1394 06fc 0200A0E3 		mov	r0, #2
 1395 0700 FEFFFFEB 		bl	mframe_disable
 479:layer1/l23_api.c **** 	if (ccch_mode == CCCH_MODE_COMBINED)
 1396              		.loc 1 479 0
 1397 0704 020054E3 		cmp	r4, #2
 480:layer1/l23_api.c **** 		mframe_enable(MF_TASK_CCCH_COMB);
 1398              		.loc 1 480 0
 1399 0708 0300A003 		moveq	r0, #3
 479:layer1/l23_api.c **** 	if (ccch_mode == CCCH_MODE_COMBINED)
 1400              		.loc 1 479 0
 1401 070c 0200000A 		beq	.L87
 481:layer1/l23_api.c **** 	else if (ccch_mode == CCCH_MODE_NON_COMBINED)
 1402              		.loc 1 481 0
 1403 0710 010054E3 		cmp	r4, #1
 1404 0714 0100001A 		bne	.L68
 482:layer1/l23_api.c **** 		mframe_enable(MF_TASK_CCCH);
 1405              		.loc 1 482 0
 1406 0718 0200A0E3 		mov	r0, #2
 1407              	.L87:
 1408 071c FEFFFFEB 		bl	mframe_enable
 1409              	.L68:
 1410              	.LVL143:
 1411              	.LBB334:
 1412              	.LBB335:
 455:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_CCCH_MODE_CONF);
 1413              		.loc 1 455 0
 1414 0720 1100A0E3 		mov	r0, #17
 1415 0724 FEFFFFEB 		bl	l1ctl_msgb_alloc
 458:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 1416              		.loc 1 458 0
 1417 0728 0410A0E3 		mov	r1, #4
 455:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_CCCH_MODE_CONF);
 1418              		.loc 1 455 0
 1419 072c 0050A0E1 		mov	r5, r0
 1420              	.LVL144:
 458:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 1421              		.loc 1 458 0
 1422 0730 FEFFFFEB 		bl	msgb_put
 1423              	.LVL145:
 459:layer1/l23_api.c **** 	mode_conf->ccch_mode = ccch_mode;
 1424              		.loc 1 459 0
 1425 0734 0040C0E5 		strb	r4, [r0, #0]
 461:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 1426              		.loc 1 461 0
 1427 0738 0500A0E1 		mov	r0, r5
 1428              	.LVL146:
 1429 073c 190000EA 		b	.L89
 1430              	.LVL147:
 1431              	.L39:
 1432              	.LBE335:
 1433              	.LBE334:
 1434              	.LBE333:
 1435              	.LBE332:
 1436              	.LBB336:
 1437              	.LBB337:
 509:layer1/l23_api.c **** 	printd("L1CTL_TCH_MODE_REQ (tch_mode=0x%02x audio_mode=0x%02x)\n",
 1438              		.loc 1 509 0
 1439 0740 0450D4E5 		ldrb	r5, [r4, #4]	@ zero_extendqisi2
 1440 0744 0540D4E5 		ldrb	r4, [r4, #5]	@ zero_extendqisi2
 1441              	.LVL148:
 1442 0748 0510A0E1 		mov	r1, r5
 1443 074c 0420A0E1 		mov	r2, r4
 1444 0750 F4019FE5 		ldr	r0, .L93+116
 1445 0754 FEFFFFEB 		bl	printf
 1446              	.LVL149:
 511:layer1/l23_api.c **** 	tch_mode = l1a_tch_mode_set(tch_mode);
 1447              		.loc 1 511 0
 1448 0758 0500A0E1 		mov	r0, r5
 1449 075c FEFFFFEB 		bl	l1a_tch_mode_set
 1450 0760 0050A0E1 		mov	r5, r0
 1451              	.LVL150:
 512:layer1/l23_api.c **** 	audio_mode = l1a_audio_mode_set(audio_mode);
 1452              		.loc 1 512 0
 1453 0764 0400A0E1 		mov	r0, r4
 1454              	.LVL151:
 1455 0768 FEFFFFEB 		bl	l1a_audio_mode_set
 1456 076c 0040A0E1 		mov	r4, r0
 1457              	.LVL152:
 514:layer1/l23_api.c **** 	audio_set_enabled(tch_mode, audio_mode);
 1458              		.loc 1 514 0
 1459 0770 0410A0E1 		mov	r1, r4
 1460 0774 0500A0E1 		mov	r0, r5
 1461              	.LVL153:
 1462 0778 FEFFFFEB 		bl	audio_set_enabled
 1463              	.LVL154:
 516:layer1/l23_api.c **** 	l1s.tch_sync = 1; /* Needed for audio to work */
 1464              		.loc 1 516 0
 1465 077c 64319FE5 		ldr	r3, .L93+16
 1466 0780 0120A0E3 		mov	r2, #1
 1467 0784 4B2AC3E5 		strb	r2, [r3, #2635]
 1468              	.LVL155:
 1469              	.LBB338:
 1470              	.LBB339:
 490:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_TCH_MODE_CONF);
 1471              		.loc 1 490 0
 1472 0788 1900A0E3 		mov	r0, #25
 1473 078c FEFFFFEB 		bl	l1ctl_msgb_alloc
 493:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 1474              		.loc 1 493 0
 1475 0790 0410A0E3 		mov	r1, #4
 490:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_TCH_MODE_CONF);
 1476              		.loc 1 490 0
 1477 0794 0070A0E1 		mov	r7, r0
 1478              	.LVL156:
 493:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 1479              		.loc 1 493 0
 1480 0798 FEFFFFEB 		bl	msgb_put
 1481              	.LVL157:
 494:layer1/l23_api.c **** 	mode_conf->tch_mode = tch_mode;
 1482              		.loc 1 494 0
 1483 079c 0050C0E5 		strb	r5, [r0, #0]
 495:layer1/l23_api.c **** 	mode_conf->audio_mode = audio_mode;
 1484              		.loc 1 495 0
 1485 07a0 0140C0E5 		strb	r4, [r0, #1]
 497:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 1486              		.loc 1 497 0
 1487 07a4 0700A0E1 		mov	r0, r7
 1488              	.LVL158:
 1489              	.L89:
 1490 07a8 FEFFFFEB 		bl	l1_queue_for_l2
 1491              	.LBE339:
 1492              	.LBE338:
 1493              	.LBE337:
 1494              	.LBE336:
 667:layer1/l23_api.c **** 		break;
 1495              		.loc 1 667 0
 1496 07ac 430000EA 		b	.L26
 1497              	.LVL159:
 1498              	.L40:
 1499              	.LBB340:
 1500              	.LBB341:
 530:layer1/l23_api.c **** 	l1s.neigh_pm.n = 0; /* atomic */
 1501              		.loc 1 530 0
 1502 07b0 30319FE5 		ldr	r3, .L93+16
 1503 07b4 0020A0E3 		mov	r2, #0
 526:layer1/l23_api.c **** 		(struct l1ctl_neigh_pm_req *) l1h->data;
 1504              		.loc 1 526 0
 1505 07b8 04E084E2 		add	lr, r4, #4
 1506              	.LVL160:
 530:layer1/l23_api.c **** 	l1s.neigh_pm.n = 0; /* atomic */
 1507              		.loc 1 530 0
 1508 07bc 1C2CC3E5 		strb	r2, [r3, #3100]
 531:layer1/l23_api.c **** 	l1s.neigh_pm.second = 0;
 1509              		.loc 1 531 0
 1510 07c0 1D2CC3E5 		strb	r2, [r3, #3101]
 533:layer1/l23_api.c **** 	l1s.neigh_pm.pos = 0;
 1511              		.loc 1 533 0
 1512 07c4 1E2CC3E5 		strb	r2, [r3, #3102]
 534:layer1/l23_api.c **** 	l1s.neigh_pm.running = 0;
 1513              		.loc 1 534 0
 1514 07c8 1F2CC3E5 		strb	r2, [r3, #3103]
 1515              	.LVL161:
 1516 07cc 7CC19FE5 		ldr	ip, .L93+120
 599:layer1/l23_api.c **** void l1a_l23_handler(void)
 1517              		.loc 1 599 0
 1518 07d0 850084E2 		add	r0, r4, #133
 1519 07d4 0A0000EA 		b	.L69
 1520              	.LVL162:
 1521              	.L70:
 536:layer1/l23_api.c **** 		l1s.neigh_pm.band_arfcn[i] = ntohs(pm_req->band_arfcn[i]);
 1522              		.loc 1 536 0
 1523 07d8 82508EE0 		add	r5, lr, r2, asl #1
 1524 07dc 0210D5E5 		ldrb	r1, [r5, #2]	@ zero_extendqisi2
 1525 07e0 0350D5E5 		ldrb	r5, [r5, #3]	@ zero_extendqisi2
 1526 07e4 051481E1 		orr	r1, r1, r5, asl #8
 1527              	.LVL163:
 1528              	.LBB342:
 1529              	.LBB343:
 1530              		.loc 4 51 0
 1531 07e8 2154A0E1 		mov	r5, r1, lsr #8
 1532 07ec 011485E1 		orr	r1, r5, r1, asl #8
 1533              	.LVL164:
 1534              	.LBE343:
 1535              	.LBE342:
 536:layer1/l23_api.c **** 		l1s.neigh_pm.band_arfcn[i] = ntohs(pm_req->band_arfcn[i]);
 1536              		.loc 1 536 0
 1537 07f0 B210ECE1 		strh	r1, [ip, #2]!	@ movhi
 537:layer1/l23_api.c **** 		l1s.neigh_pm.tn[i] = pm_req->tn[i];
 1538              		.loc 1 537 0
 1539 07f4 0150F0E5 		ldrb	r5, [r0, #1]!	@ zero_extendqisi2
 599:layer1/l23_api.c **** void l1a_l23_handler(void)
 1540              		.loc 1 599 0
 1541 07f8 021083E0 		add	r1, r3, r2
 537:layer1/l23_api.c **** 		l1s.neigh_pm.tn[i] = pm_req->tn[i];
 1542              		.loc 1 537 0
 1543 07fc A05CC1E5 		strb	r5, [r1, #3232]
 535:layer1/l23_api.c **** 	for (i = 0; i < pm_req->n; i++) {
 1544              		.loc 1 535 0
 1545 0800 012082E2 		add	r2, r2, #1
 1546              	.LVL165:
 1547              	.L69:
 1548 0804 0010DEE5 		ldrb	r1, [lr, #0]	@ zero_extendqisi2
 1549 0808 010052E1 		cmp	r2, r1
 1550 080c D4509FE5 		ldr	r5, .L93+16
 1551 0810 F0FFFFBA 		blt	.L70
 539:layer1/l23_api.c **** 	printf("L1CTL_NEIGH_PM_REQ new list with %u entries\n", pm_req->n);
 1552              		.loc 1 539 0
 1553 0814 38019FE5 		ldr	r0, .L93+124
 1554 0818 FEFFFFEB 		bl	printf
 1555              	.LVL166:
 540:layer1/l23_api.c **** 	l1s.neigh_pm.n = pm_req->n; /* atomic */
 1556              		.loc 1 540 0
 1557 081c 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1558 0820 1C3CC5E5 		strb	r3, [r5, #3100]
 543:layer1/l23_api.c **** 	if (l1s.dedicated.type == GSM_DCHAN_NONE)
 1559              		.loc 1 543 0
 1560 0824 083B95E5 		ldr	r3, [r5, #2824]
 1561 0828 000053E3 		cmp	r3, #0
 1562 082c 2300001A 		bne	.L26
 544:layer1/l23_api.c **** 		mframe_enable(MF_TASK_NEIGH_PM51_C0T0);
 1563              		.loc 1 544 0
 1564 0830 1400A0E3 		mov	r0, #20
 1565 0834 FEFFFFEB 		bl	mframe_enable
 1566 0838 200000EA 		b	.L26
 1567              	.LVL167:
 1568              	.L41:
 1569              	.LBE341:
 1570              	.LBE340:
 1571              	.LBB344:
 1572              	.LBB345:
 552:layer1/l23_api.c **** 	struct l1ctl_traffic_req *tr = (struct l1ctl_traffic_req *) ul->payload;
 1573              		.loc 1 552 0
 1574 083c 084084E2 		add	r4, r4, #8
 1575              	.LVL168:
 557:layer1/l23_api.c **** 	msg->l2h = tr->data;
 1576              		.loc 1 557 0
 1577 0840 144086E5 		str	r4, [r6, #20]
 559:layer1/l23_api.c **** 	num = l1a_txq_msgb_count(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 1578              		.loc 1 559 0
 1579 0844 0C019FE5 		ldr	r0, .L93+128
 1580 0848 FEFFFFEB 		bl	l1a_txq_msgb_count
 1581              	.LVL169:
 560:layer1/l23_api.c **** 	if (num >= 4) {
 1582              		.loc 1 560 0
 1583 084c 030050E3 		cmp	r0, #3
 561:layer1/l23_api.c **** 		printd("dropping traffic frame\n");
 1584              		.loc 1 561 0
 1585 0850 04019FC5 		ldrgt	r0, .L93+132
 1586              	.LVL170:
 560:layer1/l23_api.c **** 	if (num >= 4) {
 1587              		.loc 1 560 0
 1588 0854 A1FFFFCA 		bgt	.L90
 566:layer1/l23_api.c **** 	l1a_txq_msgb_enq(&l1s.tx_queue[L1S_CHAN_TRAFFIC], msg);
 1589              		.loc 1 566 0
 1590 0858 F8009FE5 		ldr	r0, .L93+128
 1591              	.LVL171:
 1592              	.L91:
 1593 085c 0610A0E1 		mov	r1, r6
 1594              	.LBE345:
 1595              	.LBE344:
 1596              		.loc 1 684 0
 1597 0860 08D08DE2 		add	sp, sp, #8
 1598 0864 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 1599              	.LBB347:
 1600              	.LBB346:
 566:layer1/l23_api.c **** 	l1a_txq_msgb_enq(&l1s.tx_queue[L1S_CHAN_TRAFFIC], msg);
 1601              		.loc 1 566 0
 1602 0868 FEFFFFEA 		b	l1a_txq_msgb_enq
 1603              	.LVL172:
 1604              	.L38:
 1605              	.LBE346:
 1606              	.LBE347:
 1607              	.LBB348:
 1608              	.LBB349:
 571:layer1/l23_api.c **** 	uint16_t len = msg->len - sizeof(struct l1ctl_hdr);
 1609              		.loc 1 571 0
 1610 086c 045041E2 		sub	r5, r1, #4
 1611              	.LBB351:
 577:layer1/l23_api.c **** 		printf("SIM Request (%u): ", len);
 1612              		.loc 1 577 0
 1613 0870 0558A0E1 		mov	r5, r5, asl #16
 1614 0874 2558A0E1 		mov	r5, r5, lsr #16
 1615 0878 E0009FE5 		ldr	r0, .L93+136
 1616 087c 0510A0E1 		mov	r1, r5
 1617              	.LVL173:
 1618              	.LBE351:
 572:layer1/l23_api.c **** 	uint8_t *data = msg->data + sizeof(struct l1ctl_hdr);
 1619              		.loc 1 572 0
 1620 0880 048084E2 		add	r8, r4, #4
 1621              	.LVL174:
 1622              	.LBB350:
 577:layer1/l23_api.c **** 		printf("SIM Request (%u): ", len);
 1623              		.loc 1 577 0
 1624 0884 FEFFFFEB 		bl	printf
 1625              	.LVL175:
 599:layer1/l23_api.c **** void l1a_l23_handler(void)
 1626              		.loc 1 599 0
 1627 0888 034084E2 		add	r4, r4, #3
 1628              	.LVL176:
 1629              	.LBE350:
 1630              	.LBE349:
 1631              	.LBE348:
 1632              	.LBB354:
 1633              	.LBB316:
 1634              	.LBB315:
 578:layer1/l23_api.c **** 		for (i = 0; i < len; i++)
 1635              		.loc 1 578 0
 1636 088c 0070A0E3 		mov	r7, #0
 1637 0890 030000EA 		b	.L72
 1638              	.LVL177:
 1639              	.L73:
 1640              	.LBE315:
 1641              	.LBE316:
 1642              	.LBE354:
 1643              	.LBB355:
 1644              	.LBB353:
 1645              	.LBB352:
 579:layer1/l23_api.c **** 			printf("%02x ", data[i]);
 1646              		.loc 1 579 0
 1647 0894 C8009FE5 		ldr	r0, .L93+140
 1648 0898 0110F4E5 		ldrb	r1, [r4, #1]!	@ zero_extendqisi2
 1649 089c FEFFFFEB 		bl	printf
 578:layer1/l23_api.c **** 		for (i = 0; i < len; i++)
 1650              		.loc 1 578 0
 1651 08a0 017087E2 		add	r7, r7, #1
 1652              	.LVL178:
 1653              	.L72:
 1654 08a4 050057E1 		cmp	r7, r5
 1655 08a8 F9FFFFBA 		blt	.L73
 580:layer1/l23_api.c **** 		puts("\n");
 1656              		.loc 1 580 0
 1657 08ac B4009FE5 		ldr	r0, .L93+144
 1658 08b0 FEFFFFEB 		bl	puts
 1659              	.LBE352:
 584:layer1/l23_api.c ****    sim_apdu(len, data);
 1660              		.loc 1 584 0
 1661 08b4 0500A0E1 		mov	r0, r5
 1662 08b8 0810A0E1 		mov	r1, r8
 1663 08bc FEFFFFEB 		bl	sim_apdu
 1664              	.LVL179:
 1665              	.L26:
 1666              	.LBE353:
 1667              	.LBE355:
 681:layer1/l23_api.c **** 	msgb_free(msg);
 1668              		.loc 1 681 0
 1669 08c0 0600A0E1 		mov	r0, r6
 1670              		.loc 1 684 0
 1671 08c4 08D08DE2 		add	sp, sp, #8
 1672 08c8 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 681:layer1/l23_api.c **** 	msgb_free(msg);
 1673              		.loc 1 681 0
 1674 08cc FEFFFFEA 		b	msgb_free
 1675              	.L24:
 1676              	.L23:
 1677              		.loc 1 684 0
 1678 08d0 08D08DE2 		add	sp, sp, #8
 1679 08d4 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 1680              	.L94:
 1681              		.align	2
 1682              	.L93:
 1683 08d8 00000000 		.word	.LANCHOR0
 1684 08dc 52000000 		.word	.LC3
 1685 08e0 71000000 		.word	.LC4
 1686 08e4 85000000 		.word	.LC5
 1687 08e8 00000000 		.word	l1s
 1688 08ec AC000000 		.word	.LC6
 1689 08f0 C6000000 		.word	.LC7
 1690 08f4 120B0000 		.word	l1s+2834
 1691 08f8 00000000 		.word	.LANCHOR2
 1692 08fc FB000000 		.word	.LC8
 1693 0900 580A0000 		.word	l1s+2648
 1694 0904 0C010000 		.word	.LC9
 1695 0908 32010000 		.word	.LC10
 1696 090c 9A0B0000 		.word	l1s+2970
 1697 0910 980B0000 		.word	2968
 1698 0914 58010000 		.word	.LC11
 1699 0918 7F010000 		.word	.LC12
 1700 091c 9F010000 		.word	.LC13
 1701 0920 D2010000 		.word	.LC14
 1702 0924 F3010000 		.word	.LC15
 1703 0928 500A0000 		.word	l1s+2640
 1704 092c 0F020000 		.word	.LC16
 1705 0930 F80A0000 		.word	2808
 1706 0934 FA0A0000 		.word	2810
 1707 0938 FC0A0000 		.word	2812
 1708 093c 4D020000 		.word	.LC17
 1709 0940 9A020000 		.word	.LC20
 1710 0944 6B020000 		.word	.LC18
 1711 0948 82020000 		.word	.LC19
 1712 094c B7020000 		.word	.LC21
 1713 0950 1E0C0000 		.word	l1s+3102
 1714 0954 EF020000 		.word	.LC22
 1715 0958 600A0000 		.word	l1s+2656
 1716 095c 1C030000 		.word	.LC23
 1717 0960 33030000 		.word	.LC24
 1718 0964 46030000 		.word	.LC25
 1719 0968 4C030000 		.word	.LC26
 1720              		.cfi_endproc
 1721              	.LFE83:
 1723              		.section	.text.l1a_l23api_init,"ax",%progbits
 1724              		.align	2
 1725              		.global	l1a_l23api_init
 1727              	l1a_l23api_init:
 1728              	.LFB84:
 685:layer1/l23_api.c **** 
 686:layer1/l23_api.c **** void l1a_l23api_init(void)
 687:layer1/l23_api.c **** {
 1729              		.loc 1 687 0
 1730              		.cfi_startproc
 1731              		@ args = 0, pretend = 0, frame = 0
 1732              		@ frame_needed = 0, uses_anonymous_args = 0
 1733              		@ link register save eliminated.
 688:layer1/l23_api.c **** 	sercomm_register_rx_cb(SC_DLCI_L1A_L23, l1a_l23_rx);
 1734              		.loc 1 688 0
 1735 0000 04109FE5 		ldr	r1, .L96
 1736 0004 0500A0E3 		mov	r0, #5
 689:layer1/l23_api.c **** }
 1737              		.loc 1 689 0
 688:layer1/l23_api.c **** 	sercomm_register_rx_cb(SC_DLCI_L1A_L23, l1a_l23_rx);
 1738              		.loc 1 688 0
 1739 0008 FEFFFFEA 		b	sercomm_register_rx_cb
 1740              	.L97:
 1741              		.align	2
 1742              	.L96:
 1743 000c 00000000 		.word	l1a_l23_rx
 1744              		.cfi_endproc
 1745              	.LFE84:
 1747              		.global	l1a_l23_tx_cb
 1748              		.section	.rodata
 1749              		.align	2
 1750              		.set	.LANCHOR2,. + 0
 1753              	CSWTCH.32:
 1754 0000 00002000 		.word	2097152
 1755 0004 00008000 		.word	8388608
 1756 0008 00004000 		.word	4194304
 1757              		.section	.rodata.str1.1,"aMS",%progbits,1
 1758              	.LC0:
 1759 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 1759      28257029 
 1759      3A204E6F 
 1759      7420656E 
 1759      6F756768 
 1760 0032 00       		.ascii	"\000"
 1761              	.LC1:
 1762 0033 6C316374 		.ascii	"l1ctl\000"
 1762      6C00
 1763              	.LC2:
 1764 0039 4F4F5053 		.ascii	"OOPS. Out of buffers...\012\000"
 1764      2E204F75 
 1764      74206F66 
 1764      20627566 
 1764      66657273 
 1765              	.LC3:
 1766 0052 6C31615F 		.ascii	"l1a_l23_cb: Short message. %u\012\000"
 1766      6C32335F 
 1766      63623A20 
 1766      53686F72 
 1766      74206D65 
 1767              	.LC4:
 1768 0071 53686F72 		.ascii	"Short sync msg. %u\012\000"
 1768      74207379 
 1768      6E63206D 
 1768      73672E20 
 1768      25750A00 
 1769              	.LC5:
 1770 0085 4C314354 		.ascii	"L1CTL_FBSB_REQ (arfcn=%u, flags=0x%x)\012\000"
 1770      4C5F4642 
 1770      53425F52 
 1770      45512028 
 1770      61726663 
 1771              	.LC6:
 1772 00ac 53746172 		.ascii	"Starting FCCH Recognition\000"
 1772      74696E67 
 1772      20464343 
 1772      48205265 
 1772      636F676E 
 1773              	.LC7:
 1774 00c6 4C314354 		.ascii	"L1CTL_DM_EST_REQ (arfcn=%u, chan_nr=0x%02x, tsc=%u)"
 1774      4C5F444D 
 1774      5F455354 
 1774      5F524551 
 1774      20286172 
 1775 00f9 0A00     		.ascii	"\012\000"
 1776              	.LC8:
 1777 00fb 4C314354 		.ascii	"L1CTL_DM_REL_REQ\000"
 1777      4C5F444D 
 1777      5F52454C 
 1777      5F524551 
 1777      00
 1778              	.LC9:
 1779 010c 4C314354 		.ascii	"L1CTL_PARAM_REQ (ta=%d, tx_power=%d)\012\000"
 1779      4C5F5041 
 1779      52414D5F 
 1779      52455120 
 1779      2874613D 
 1780              	.LC10:
 1781 0132 4C314354 		.ascii	"L1CTL_DM_FREQ_REQ (arfcn=%u, tsc=%u)\012\000"
 1781      4C5F444D 
 1781      5F465245 
 1781      515F5245 
 1781      51202861 
 1782              	.LC11:
 1783 0158 4C314354 		.ascii	"L1CTL_CRYPTO_REQ (algo=A5/%u, len=%u)\012\000"
 1783      4C5F4352 
 1783      5950544F 
 1783      5F524551 
 1783      2028616C 
 1784              	.LC12:
 1785 017f 4C314354 		.ascii	"L1CTL_CRYPTO_REQ -> Invalid key\000"
 1785      4C5F4352 
 1785      5950544F 
 1785      5F524551 
 1785      202D3E20 
 1786              	.LC13:
 1787 019f 4C314354 		.ascii	"L1CTL_RACH_REQ (ra=0x%02x, offset=%d combined=%d)\012"
 1787      4C5F5241 
 1787      43485F52 
 1787      45512028 
 1787      72613D30 
 1788 01d1 00       		.ascii	"\000"
 1789              	.LC14:
 1790 01d2 4C314354 		.ascii	"L1CTL_DATA_REQ (link_id=0x%02x)\012\000"
 1790      4C5F4441 
 1790      54415F52 
 1790      45512028 
 1790      6C696E6B 
 1791              	.LC15:
 1792 01f3 75706461 		.ascii	"updating measurement report\000"
 1792      74696E67 
 1792      206D6561 
 1792      73757265 
 1792      6D656E74 
 1793              	.LC16:
 1794 020f 756C3D25 		.ascii	"ul=%p, ul->payload=%p, data_ind=%p, data_ind->data="
 1794      702C2075 
 1794      6C2D3E70 
 1794      61796C6F 
 1794      61643D25 
 1795 0242 2570206C 		.ascii	"%p l3h=%p\012\000"
 1795      33683D25 
 1795      700A00
 1796              	.LC17:
 1797 024d 4C314354 		.ascii	"L1CTL_PM_REQ start=%u end=%u\012\000"
 1797      4C5F504D 
 1797      5F524551 
 1797      20737461 
 1797      72743D25 
 1798              	.LC18:
 1799 026b 4C314354 		.ascii	"L1CTL_RESET_REQ: FULL!\000"
 1799      4C5F5245 
 1799      5345545F 
 1799      5245513A 
 1799      2046554C 
 1800              	.LC19:
 1801 0282 4C314354 		.ascii	"L1CTL_RESET_REQ: SCHED!\000"
 1801      4C5F5245 
 1801      5345545F 
 1801      5245513A 
 1801      20534348 
 1802              	.LC20:
 1803 029a 756E6B6E 		.ascii	"unknown L1CTL_RESET_REQ type\000"
 1803      6F776E20 
 1803      4C314354 
 1803      4C5F5245 
 1803      5345545F 
 1804              	.LC21:
 1805 02b7 4C314354 		.ascii	"L1CTL_TCH_MODE_REQ (tch_mode=0x%02x audio_mode=0x%0"
 1805      4C5F5443 
 1805      485F4D4F 
 1805      44455F52 
 1805      45512028 
 1806 02ea 3278290A 		.ascii	"2x)\012\000"
 1806      00
 1807              	.LC22:
 1808 02ef 4C314354 		.ascii	"L1CTL_NEIGH_PM_REQ new list with %u entries\012\000"
 1808      4C5F4E45 
 1808      4947485F 
 1808      504D5F52 
 1808      4551206E 
 1809              	.LC23:
 1810 031c 64726F70 		.ascii	"dropping traffic frame\000"
 1810      70696E67 
 1810      20747261 
 1810      66666963 
 1810      20667261 
 1811              	.LC24:
 1812 0333 53494D20 		.ascii	"SIM Request (%u): \000"
 1812      52657175 
 1812      65737420 
 1812      28257529 
 1812      3A2000
 1813              	.LC25:
 1814 0346 25303278 		.ascii	"%02x \000"
 1814      2000
 1815              	.LC26:
 1816 034c 0A00     		.ascii	"\012\000"
 1817              		.data
 1818              		.align	2
 1819              		.set	.LANCHOR0,. + 0
 1822              	l23_rx_queue:
 1823 0000 00000000 		.word	l23_rx_queue
 1824 0004 00000000 		.word	l23_rx_queue
 1825              		.bss
 1826              		.align	2
 1827              		.set	.LANCHOR1,. + 0
 1830              	l1a_l23_tx_cb:
 1831 0000 00000000 		.space	4
 1832              		.text
 1833              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 l23_api.c
     /tmp/ccnQofFb.s:12     .text.audio_set_enabled:0000000000000000 $a
     /tmp/ccnQofFb.s:14     .text.audio_set_enabled:0000000000000000 audio_set_enabled
     /tmp/ccnQofFb.s:66     .text.msgb_put:0000000000000000 $a
     /tmp/ccnQofFb.s:68     .text.msgb_put:0000000000000000 msgb_put
     /tmp/ccnQofFb.s:133    .text.msgb_put:0000000000000054 $d
     /tmp/ccnQofFb.s:138    .text.l1a_l23_rx:0000000000000000 $a
     /tmp/ccnQofFb.s:141    .text.l1a_l23_rx:0000000000000000 l1a_l23_rx
     /tmp/ccnQofFb.s:176    .text.l1a_l23_rx:0000000000000020 $d
     /tmp/ccnQofFb.s:181    .text.l1_queue_for_l2:0000000000000000 $a
     /tmp/ccnQofFb.s:184    .text.l1_queue_for_l2:0000000000000000 l1_queue_for_l2
     /tmp/ccnQofFb.s:223    .text.l1_queue_for_l2:0000000000000030 $d
     /tmp/ccnQofFb.s:228    .text.l1ctl_msgb_alloc:0000000000000000 $a
     /tmp/ccnQofFb.s:231    .text.l1ctl_msgb_alloc:0000000000000000 l1ctl_msgb_alloc
     /tmp/ccnQofFb.s:302    .text.l1ctl_msgb_alloc:0000000000000060 $d
     /tmp/ccnQofFb.s:308    .text.l1_create_l2_msg:0000000000000000 $a
     /tmp/ccnQofFb.s:311    .text.l1_create_l2_msg:0000000000000000 l1_create_l2_msg
     /tmp/ccnQofFb.s:411    .text.l1ctl_tx_reset:0000000000000000 $a
     /tmp/ccnQofFb.s:414    .text.l1ctl_tx_reset:0000000000000000 l1ctl_tx_reset
     /tmp/ccnQofFb.s:455    .text.l1a_l23_handler:0000000000000000 $a
     /tmp/ccnQofFb.s:458    .text.l1a_l23_handler:0000000000000000 l1a_l23_handler
     /tmp/ccnQofFb.s:517    .text.l1a_l23_handler:0000000000000054 $d
     /tmp/ccnQofFb.s:550    .text.l1a_l23_handler:00000000000000c4 $a
     /tmp/ccnQofFb.s:1683   .text.l1a_l23_handler:00000000000008d8 $d
     /tmp/ccnQofFb.s:1724   .text.l1a_l23api_init:0000000000000000 $a
     /tmp/ccnQofFb.s:1727   .text.l1a_l23api_init:0000000000000000 l1a_l23api_init
     /tmp/ccnQofFb.s:1743   .text.l1a_l23api_init:000000000000000c $d
     /tmp/ccnQofFb.s:1830   .bss:0000000000000000 l1a_l23_tx_cb
     /tmp/ccnQofFb.s:1749   .rodata:0000000000000000 $d
     /tmp/ccnQofFb.s:1753   .rodata:0000000000000000 CSWTCH.32
     /tmp/ccnQofFb.s:1818   .data:0000000000000000 $d
     /tmp/ccnQofFb.s:1822   .data:0000000000000000 l23_rx_queue
     /tmp/ccnQofFb.s:1826   .bss:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
twl3025_unit_enable
osmo_panic
msgb_enqueue
sercomm_sendmsg
msgb_alloc
puts
msgb_dequeue
printf
l1s_reset
l1s_fbsb_req
mframe_disable
l1a_tch_mode_set
l1a_audio_mode_set
l1a_mftask_set
l1a_txq_msgb_flush
l1a_meas_msgb_set
dsp_load_ciph_param
l1a_freq_req
l1a_rach_req
l1s_reset_hw
l1s_pm_test
sched_gsmtime_reset
mframe_enable
l1a_txq_msgb_count
l1a_txq_msgb_enq
sim_apdu
msgb_free
l1s
sercomm_register_rx_cb
